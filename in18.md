# Flutter Internationalization & Localization - 25 Essential Examples

This comprehensive guide covers Flutter internationalization (i18n) and  
localization (l10n) with 25 practical examples, from basic setup to advanced  
techniques. Each example demonstrates different aspects of creating  
multilingual apps that adapt to different locales, cultures, and regions.

## Basic Localization Setup

Setting up internationalization support with the intl package and  
basic locale configuration.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Basic Localization',
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'), // English
        Locale('es', 'ES'), // Spanish
        Locale('fr', 'FR'), // French
        Locale('de', 'DE'), // German
      ],
      home: const HomePage(),
    );
  }
}

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Basic Localization'),
      ),
      body: const Padding(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'System Locale Information',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            LocaleInfoWidget(),
          ],
        ),
      ),
    );
  }
}

class LocaleInfoWidget extends StatelessWidget {
  const LocaleInfoWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Language Code: ${locale.languageCode}'),
            Text('Country Code: ${locale.countryCode ?? "N/A"}'),
            Text('Script Code: ${locale.scriptCode ?? "N/A"}'),
            Text('Full Locale: ${locale.toString()}'),
          ],
        ),
      ),
    );
  }
}
```

This basic setup enables Flutter's built-in localization support for  
Material Design components. The supportedLocales list defines which  
languages your app supports, while localizationsDelegates provide  
the translations for system UI elements like buttons and dialogs.  
The LocaleInfoWidget displays current locale information for debugging.

## Manual Locale Switching

Creating a language selector that allows users to manually change  
the app's language at runtime.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Manual Locale Switching',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('es', 'ES'),
        Locale('fr', 'FR'),
        Locale('de', 'DE'),
        Locale('ja', 'JP'),
        Locale('zh', 'CN'),
      ],
      home: LanguageSwitcherPage(onLocaleChange: _changeLocale),
    );
  }
}

class LanguageSwitcherPage extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const LanguageSwitcherPage({
    super.key,
    required this.onLocaleChange,
  });

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English',
    Locale('es', 'ES'): '🇪🇸 Español',
    Locale('fr', 'FR'): '🇫🇷 Français',
    Locale('de', 'DE'): '🇩🇪 Deutsch',
    Locale('ja', 'JP'): '🇯🇵 日本語',
    Locale('zh', 'CN'): '🇨🇳 中文',
  };

  @override
  Widget build(BuildContext context) {
    final currentLocale = Localizations.localeOf(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Language Selector'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Row(
                    children: [
                      Text(entry.value),
                      if (entry.key == currentLocale) ...[
                        const Spacer(),
                        const Icon(Icons.check, color: Colors.green),
                      ],
                    ],
                  ),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            Card(
              child: ListTile(
                leading: const Icon(Icons.info),
                title: const Text('Current Locale'),
                subtitle: Text(
                  '${_localeNames[currentLocale] ?? currentLocale.toString()}\n'
                  'Language: ${currentLocale.languageCode}\n'
                  'Country: ${currentLocale.countryCode ?? "N/A"}',
                ),
              ),
            ),
            const SizedBox(height: 20),
            const Text(
              'Available Languages',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                itemCount: _localeNames.length,
                itemBuilder: (context, index) {
                  final entry = _localeNames.entries.elementAt(index);
                  final isSelected = entry.key == currentLocale;
                  
                  return Card(
                    color: isSelected ? Colors.blue[50] : null,
                    child: ListTile(
                      leading: CircleAvatar(
                        child: Text(entry.value.split(' ')[0]),
                      ),
                      title: Text(entry.value.split(' ')[1]),
                      subtitle: Text(
                        'Code: ${entry.key.languageCode}-'
                        '${entry.key.countryCode}',
                      ),
                      trailing: isSelected
                          ? const Icon(Icons.check_circle, color: Colors.green)
                          : null,
                      onTap: () => onLocaleChange(entry.key),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

The manual locale switching example demonstrates how to change the app's  
language dynamically. The _changeLocale callback updates the MaterialApp's  
locale property, triggering a rebuild with the new language. The popup  
menu provides an intuitive way for users to select their preferred  
language, with visual indicators showing the current selection.

## ARB File Translations

Using Application Resource Bundle (ARB) files for structured  
internationalization with generated code.  

First, create the ARB files in your project:

**lib/l10n/app_en.arb:**
```json
{
  "@@locale": "en",
  "appTitle": "My App",
  "@appTitle": {
    "description": "The title of the application"
  },
  "welcomeMessage": "Welcome to our app!",
  "@welcomeMessage": {
    "description": "Welcome message shown on the home screen"
  },
  "itemCount": "{count, plural, =0{No items} =1{1 item} other{{count} items}}",
  "@itemCount": {
    "description": "Number of items in the list",
    "placeholders": {
      "count": {
        "type": "int",
        "format": "compact"
      }
    }
  },
  "greetUser": "Hello {name}!",
  "@greetUser": {
    "description": "Greeting message for a user",
    "placeholders": {
      "name": {
        "type": "String",
        "example": "John"
      }
    }
  }
}
```

**lib/l10n/app_es.arb:**
```json
{
  "@@locale": "es",
  "appTitle": "Mi Aplicación",
  "welcomeMessage": "¡Bienvenido a nuestra aplicación!",
  "itemCount": "{count, plural, =0{Sin elementos} =1{1 elemento} other{{count} elementos}}",
  "greetUser": "¡Hola {name}!"
}
```

**pubspec.yaml configuration:**
```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  intl: any

dev_dependencies:
  flutter_gen: ^5.3.2

flutter:
  generate: true

flutter_intl:
  enabled: true
```

**l10n.yaml:**
```yaml
arb-dir: lib/l10n
template-arb-file: app_en.arb
output-localization-file: app_localizations.dart
output-class: AppLocalizations
```

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ARB Translations',
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
      ],
      home: const TranslationExample(),
    );
  }
}

class TranslationExample extends StatefulWidget {
  const TranslationExample({super.key});

  @override
  State<TranslationExample> createState() => _TranslationExampleState();
}

class _TranslationExampleState extends State<TranslationExample> {
  int _itemCount = 0;
  final TextEditingController _nameController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _nameController.text = 'John';
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final localizations = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.appTitle),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      localizations.welcomeMessage,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      controller: _nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name',
                        border: OutlineInputBorder(),
                      ),
                      onChanged: (_) => setState(() {}),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      localizations.greetUser(_nameController.text),
                      style: const TextStyle(fontSize: 18),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Pluralization Example',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      localizations.itemCount(_itemCount),
                      style: const TextStyle(fontSize: 18),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        ElevatedButton(
                          onPressed: _itemCount > 0
                              ? () => setState(() => _itemCount--)
                              : null,
                          child: const Text('-'),
                        ),
                        Text(
                          '$_itemCount',
                          style: const TextStyle(fontSize: 24),
                        ),
                        ElevatedButton(
                          onPressed: () => setState(() => _itemCount++),
                          child: const Text('+'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

ARB files provide a standardized way to manage translations with support  
for pluralization, parameterization, and metadata. The flutter_gen package  
automatically generates type-safe localization classes from your ARB files.  
This approach scales well for large applications and provides better  
maintainability than manual translation management.

## Number and Currency Formatting

Formatting numbers, currencies, and percentages according to different  
locale conventions using the NumberFormat class.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Number Formatting',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'), // English (US)
        Locale('de', 'DE'), // German
        Locale('fr', 'FR'), // French
        Locale('ja', 'JP'), // Japanese
        Locale('ar', 'SA'), // Arabic
        Locale('hi', 'IN'), // Hindi (India)
      ],
      home: NumberFormattingExample(onLocaleChange: _changeLocale),
    );
  }
}

class NumberFormattingExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const NumberFormattingExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<NumberFormattingExample> createState() => 
      _NumberFormattingExampleState();
}

class _NumberFormattingExampleState extends State<NumberFormattingExample> {
  double _amount = 1234567.89;
  double _percentage = 0.1234;

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English (US)',
    Locale('de', 'DE'): '🇩🇪 German',
    Locale('fr', 'FR'): '🇫🇷 French',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('hi', 'IN'): '🇮🇳 Hindi',
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Number Formatting'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildLocaleInfo(locale),
            const SizedBox(height: 20),
            _buildNumberFormats(locale),
            const SizedBox(height: 20),
            _buildCurrencyFormats(locale),
            const SizedBox(height: 20),
            _buildPercentageFormats(locale),
            const SizedBox(height: 20),
            _buildInputControls(),
          ],
        ),
      ),
    );
  }

  Widget _buildLocaleInfo(Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Current Locale: ${_localeNames[locale] ?? locale.toString()}',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            Text('Language: ${locale.languageCode}'),
            Text('Country: ${locale.countryCode ?? "N/A"}'),
          ],
        ),
      ),
    );
  }

  Widget _buildNumberFormats(Locale locale) {
    final decimalFormat = NumberFormat.decimalPattern(locale.toString());
    final compactFormat = NumberFormat.compact(locale: locale.toString());
    final scientificFormat = 
        NumberFormat.scientificPattern(locale.toString());

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Number Formats',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            _buildFormatRow('Decimal', decimalFormat.format(_amount)),
            _buildFormatRow('Compact', compactFormat.format(_amount)),
            _buildFormatRow('Scientific', scientificFormat.format(_amount)),
            _buildFormatRow(
              'Custom Pattern', 
              NumberFormat('#,##0.00', locale.toString()).format(_amount),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCurrencyFormats(Locale locale) {
    final currencyFormat = NumberFormat.currency(locale: locale.toString());
    final compactCurrency = 
        NumberFormat.compactCurrency(locale: locale.toString());
    
    // Different currencies for demonstration
    final usdFormat = NumberFormat.currency(
      locale: locale.toString(),
      symbol: '\$',
    );
    final eurFormat = NumberFormat.currency(
      locale: locale.toString(),
      symbol: '€',
    );

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Currency Formats',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            _buildFormatRow('Local Currency', currencyFormat.format(_amount)),
            _buildFormatRow('Compact Currency', 
                compactCurrency.format(_amount)),
            _buildFormatRow('USD', usdFormat.format(_amount)),
            _buildFormatRow('EUR', eurFormat.format(_amount)),
          ],
        ),
      ),
    );
  }

  Widget _buildPercentageFormats(Locale locale) {
    final percentFormat = NumberFormat.percentPattern(locale.toString());
    final decimalPercent = NumberFormat.decimalPercentPattern(
      locale: locale.toString(),
      decimalDigits: 2,
    );

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Percentage Formats',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            _buildFormatRow('Percent', percentFormat.format(_percentage)),
            _buildFormatRow('Decimal Percent', 
                decimalPercent.format(_percentage)),
          ],
        ),
      ),
    );
  }

  Widget _buildFormatRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontFamily: 'monospace'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInputControls() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Test Values',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            TextField(
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: 'Amount',
                border: const OutlineInputBorder(),
                hintText: _amount.toString(),
              ),
              onChanged: (value) {
                final parsed = double.tryParse(value);
                if (parsed != null) {
                  setState(() => _amount = parsed);
                }
              },
            ),
            const SizedBox(height: 16),
            TextField(
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: 'Percentage (0-1)',
                border: const OutlineInputBorder(),
                hintText: _percentage.toString(),
              ),
              onChanged: (value) {
                final parsed = double.tryParse(value);
                if (parsed != null && parsed >= 0 && parsed <= 1) {
                  setState(() => _percentage = parsed);
                }
              },
            ),
          ],
        ),
      ),
    );
  }
}
```

Number formatting demonstrates how different cultures express numeric  
values. The NumberFormat class automatically handles grouping separators,  
decimal points, currency symbols, and digit representations according to  
locale conventions. This ensures that numbers appear familiar and readable  
to users regardless of their cultural background.

## Date and Time Formatting

Formatting dates and times according to different cultural conventions  
using DateFormat and locale-aware patterns.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Date Formatting',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('de', 'DE'),
        Locale('fr', 'FR'),
        Locale('ja', 'JP'),
        Locale('ar', 'SA'),
        Locale('ru', 'RU'),
      ],
      home: DateFormattingExample(onLocaleChange: _changeLocale),
    );
  }
}

class DateFormattingExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const DateFormattingExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<DateFormattingExample> createState() => _DateFormattingExampleState();
}

class _DateFormattingExampleState extends State<DateFormattingExample> {
  DateTime _selectedDate = DateTime.now();
  
  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English (US)',
    Locale('de', 'DE'): '🇩🇪 German',
    Locale('fr', 'FR'): '🇫🇷 French',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('ru', 'RU'): '🇷🇺 Russian',
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Date Formatting'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildDateSelector(),
            const SizedBox(height: 20),
            _buildDateFormats(locale),
            const SizedBox(height: 20),
            _buildTimeFormats(locale),
            const SizedBox(height: 20),
            _buildRelativeDateFormats(locale),
          ],
        ),
      ),
    );
  }

  Widget _buildDateSelector() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Select Date',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: Text(
                    'Selected: ${_selectedDate.toString().split(' ')[0]}',
                    style: const TextStyle(fontSize: 16),
                  ),
                ),
                ElevatedButton(
                  onPressed: () async {
                    final date = await showDatePicker(
                      context: context,
                      initialDate: _selectedDate,
                      firstDate: DateTime(2020),
                      lastDate: DateTime(2030),
                    );
                    if (date != null) {
                      setState(() => _selectedDate = date);
                    }
                  },
                  child: const Text('Choose Date'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDateFormats(Locale locale) {
    final formats = {
      'Full': DateFormat.yMMMMEEEEd(locale.toString()),
      'Long': DateFormat.yMMMMd(locale.toString()),
      'Medium': DateFormat.yMMMd(locale.toString()),
      'Short': DateFormat.yMd(locale.toString()),
      'Custom': DateFormat('dd/MM/yyyy', locale.toString()),
      'ISO': DateFormat('yyyy-MM-dd'),
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Date Formats',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            ...formats.entries.map((entry) {
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Row(
                  children: [
                    SizedBox(
                      width: 80,
                      child: Text(
                        '${entry.key}:',
                        style: const TextStyle(fontWeight: FontWeight.w500),
                      ),
                    ),
                    Expanded(
                      child: Text(
                        entry.value.format(_selectedDate),
                        style: const TextStyle(fontFamily: 'monospace'),
                      ),
                    ),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeFormats(Locale locale) {
    final now = DateTime.now();
    final formats = {
      'Full': DateFormat.jms(locale.toString()),
      'Short': DateFormat.jm(locale.toString()),
      '24 Hour': DateFormat.Hm(locale.toString()),
      'With Seconds': DateFormat.Hms(locale.toString()),
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Time Formats',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            ...formats.entries.map((entry) {
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Row(
                  children: [
                    SizedBox(
                      width: 100,
                      child: Text(
                        '${entry.key}:',
                        style: const TextStyle(fontWeight: FontWeight.w500),
                      ),
                    ),
                    Expanded(
                      child: Text(
                        entry.value.format(now),
                        style: const TextStyle(fontFamily: 'monospace'),
                      ),
                    ),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildRelativeDateFormats(Locale locale) {
    final now = DateTime.now();
    final dates = [
      now,
      now.subtract(const Duration(days: 1)),
      now.subtract(const Duration(days: 7)),
      now.add(const Duration(days: 1)),
      now.add(const Duration(days: 30)),
    ];

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Relative Date Examples',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            ...dates.map((date) {
              final diff = date.difference(now).inDays;
              final relativeText = diff == 0 
                  ? 'Today'
                  : diff == -1 
                      ? 'Yesterday'
                      : diff == 1
                          ? 'Tomorrow'
                          : diff < 0
                              ? '${-diff} days ago'
                              : 'In $diff days';
              
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Row(
                  children: [
                    SizedBox(
                      width: 100,
                      child: Text(
                        relativeText,
                        style: const TextStyle(fontWeight: FontWeight.w500),
                      ),
                    ),
                    Expanded(
                      child: Text(
                        DateFormat.yMMMd(locale.toString()).format(date),
                        style: const TextStyle(fontFamily: 'monospace'),
                      ),
                    ),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
}
```

Date and time formatting varies significantly across cultures. Some regions  
use DD/MM/YYYY while others prefer MM/DD/YYYY or YYYY-MM-DD. Time formats  
also differ between 12-hour and 24-hour systems. The DateFormat class  
provides locale-aware formatting that automatically adapts to user  
expectations while maintaining consistency within your application.

## RTL (Right-to-Left) Language Support

Implementing proper RTL language support for Arabic, Hebrew, and other  
right-to-left languages with automatic layout direction detection.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'RTL Support',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'), // English (LTR)
        Locale('ar'), // Arabic (RTL)
        Locale('he'), // Hebrew (RTL)
        Locale('fa'), // Persian (RTL)
        Locale('ur'), // Urdu (RTL)
      ],
      home: RTLSupportExample(onLocaleChange: _changeLocale),
    );
  }
}

class RTLSupportExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const RTLSupportExample({
    super.key,
    required this.onLocaleChange,
  });

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English (LTR)',
    Locale('ar'): '🇸🇦 Arabic (RTL)',
    Locale('he'): '🇮🇱 Hebrew (RTL)',
    Locale('fa'): '🇮🇷 Persian (RTL)',
    Locale('ur'): '🇵🇰 Urdu (RTL)',
  };

  static const Map<Locale, Map<String, String>> _translations = {
    Locale('en'): {
      'title': 'RTL Language Support',
      'welcome': 'Welcome to our application',
      'description': 'This demonstrates RTL support',
      'name': 'Name',
      'email': 'Email',
      'message': 'Message',
      'send': 'Send',
      'navigation': 'Navigation',
      'home': 'Home',
      'profile': 'Profile',
      'settings': 'Settings',
    },
    Locale('ar'): {
      'title': 'دعم اللغات من اليمين إلى اليسار',
      'welcome': 'مرحباً بكم في تطبيقنا',
      'description': 'هذا يوضح دعم RTL',
      'name': 'الاسم',
      'email': 'البريد الإلكتروني',
      'message': 'الرسالة',
      'send': 'إرسال',
      'navigation': 'التنقل',
      'home': 'الرئيسية',
      'profile': 'الملف الشخصي',
      'settings': 'الإعدادات',
    },
    Locale('he'): {
      'title': 'תמיכה בשפות מימין לשמאל',
      'welcome': 'ברוכים הבאים לאפליקציה שלנו',
      'description': 'זה מדגים תמיכה ב-RTL',
      'name': 'שם',
      'email': 'דוא"ל',
      'message': 'הודעה',
      'send': 'שלח',
      'navigation': 'ניווט',
      'home': 'בית',
      'profile': 'פרופיל',
      'settings': 'הגדרות',
    },
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final isRTL = Directionality.of(context) == TextDirection.rtl;
    final texts = _translations[locale] ?? _translations[const Locale('en')]!;

    return Scaffold(
      appBar: AppBar(
        title: Text(texts['title']!),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      drawer: _buildDrawer(texts),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildDirectionInfo(isRTL, locale),
            const SizedBox(height: 20),
            _buildWelcomeCard(texts),
            const SizedBox(height: 20),
            _buildFormExample(texts),
            const SizedBox(height: 20),
            _buildListExample(texts),
            const SizedBox(height: 20),
            _buildLayoutExample(isRTL),
          ],
        ),
      ),
    );
  }

  Widget _buildDrawer(Map<String, String> texts) {
    return Drawer(
      child: ListView(
        children: [
          DrawerHeader(
            decoration: const BoxDecoration(color: Colors.blue),
            child: Text(
              texts['navigation']!,
              style: const TextStyle(color: Colors.white, fontSize: 24),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.home),
            title: Text(texts['home']!),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.person),
            title: Text(texts['profile']!),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.settings),
            title: Text(texts['settings']!),
            onTap: () {},
          ),
        ],
      ),
    );
  }

  Widget _buildDirectionInfo(bool isRTL, Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Layout Direction Information',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text('Locale: ${locale.languageCode}'),
            Text('Direction: ${isRTL ? "RTL (Right-to-Left)" : "LTR (Left-to-Right)"}'),
            Text('Auto-detected: ${isRTL ? "Yes" : "Yes"}'),
          ],
        ),
      ),
    );
  }

  Widget _buildWelcomeCard(Map<String, String> texts) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              texts['welcome']!,
              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              texts['description']!,
              style: const TextStyle(fontSize: 16),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFormExample(Map<String, String> texts) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Form Example',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            TextField(
              decoration: InputDecoration(
                labelText: texts['name']!,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              decoration: InputDecoration(
                labelText: texts['email']!,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              maxLines: 3,
              decoration: InputDecoration(
                labelText: texts['message']!,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {},
              child: Text(texts['send']!),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildListExample(Map<String, String> texts) {
    final items = [
      {'icon': Icons.home, 'title': texts['home']!},
      {'icon': Icons.person, 'title': texts['profile']!},
      {'icon': Icons.settings, 'title': texts['settings']!},
    ];

    return Card(
      child: Column(
        children: [
          const Padding(
            padding: EdgeInsets.all(16.0),
            child: Text(
              'List Example',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          ...items.map((item) => ListTile(
            leading: Icon(item['icon'] as IconData),
            title: Text(item['title'] as String),
            trailing: const Icon(Icons.arrow_forward_ios),
            onTap: () {},
          )),
        ],
      ),
    );
  }

  Widget _buildLayoutExample(bool isRTL) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Layout Direction Example',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Container(
                  width: 60,
                  height: 60,
                  color: Colors.red[200],
                  child: const Center(child: Text('1')),
                ),
                const SizedBox(width: 16),
                Container(
                  width: 60,
                  height: 60,
                  color: Colors.green[200],
                  child: const Center(child: Text('2')),
                ),
                const SizedBox(width: 16),
                Container(
                  width: 60,
                  height: 60,
                  color: Colors.blue[200],
                  child: const Center(child: Text('3')),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text('Direction: ${isRTL ? "RTL" : "LTR"}'),
            Text('Notice how elements flow ${isRTL ? "right-to-left" : "left-to-right"}'),
          ],
        ),
      ),
    );
  }
}
```

RTL language support is automatically handled by Flutter when you include  
RTL locales in your supportedLocales. The framework detects the text  
direction and adjusts layouts accordingly. UI elements like navigation  
drawers, icons, and text alignment automatically mirror for RTL languages,  
ensuring a natural reading experience for users of Arabic, Hebrew, and  
other RTL languages.

## Pluralization Rules

Implementing proper pluralization handling for different languages  
with complex plural rules using ICU message format.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Pluralization Rules',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'), // English
        Locale('pl'), // Polish (complex plurals)
        Locale('ru'), // Russian (complex plurals)
        Locale('ar'), // Arabic (dual form)
        Locale('cs'), // Czech (complex plurals)
      ],
      home: PluralizationExample(onLocaleChange: _changeLocale),
    );
  }
}

class PluralizationExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const PluralizationExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<PluralizationExample> createState() => _PluralizationExampleState();
}

class _PluralizationExampleState extends State<PluralizationExample> {
  int _itemCount = 0;
  int _messageCount = 0;
  int _personCount = 1;

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('pl'): '🇵🇱 Polish',
    Locale('ru'): '🇷🇺 Russian',
    Locale('ar'): '🇸🇦 Arabic',
    Locale('cs'): '🇨🇿 Czech',
  };

  // Pluralization patterns for different languages
  static const Map<Locale, Map<String, String>> _plurals = {
    Locale('en'): {
      'items': '{count, plural, =0{no items} =1{1 item} other{{count} items}}',
      'messages': '{count, plural, =0{no messages} =1{1 message} other{{count} messages}}',
      'people': '{count, plural, =1{1 person} other{{count} people}}',
    },
    Locale('pl'): {
      'items': '{count, plural, =0{brak elementów} =1{1 element} few{{count} elementy} many{{count} elementów} other{{count} elementów}}',
      'messages': '{count, plural, =0{brak wiadomości} =1{1 wiadomość} few{{count} wiadomości} many{{count} wiadomości} other{{count} wiadomości}}',
      'people': '{count, plural, =1{1 osoba} few{{count} osoby} many{{count} osób} other{{count} osób}}',
    },
    Locale('ru'): {
      'items': '{count, plural, =0{нет элементов} =1{1 элемент} few{{count} элемента} many{{count} элементов} other{{count} элементов}}',
      'messages': '{count, plural, =0{нет сообщений} =1{1 сообщение} few{{count} сообщения} many{{count} сообщений} other{{count} сообщений}}',
      'people': '{count, plural, =1{1 человек} few{{count} человека} many{{count} человек} other{{count} человек}}',
    },
    Locale('ar'): {
      'items': '{count, plural, =0{لا توجد عناصر} =1{عنصر واحد} =2{عنصران} few{{count} عناصر} many{{count} عنصراً} other{{count} عنصر}}',
      'messages': '{count, plural, =0{لا توجد رسائل} =1{رسالة واحدة} =2{رسالتان} few{{count} رسائل} many{{count} رسالة} other{{count} رسالة}}',
      'people': '{count, plural, =1{شخص واحد} =2{شخصان} few{{count} أشخاص} many{{count} شخصاً} other{{count} شخص}}',
    },
  };

  String _formatPlural(Locale locale, String key, int count) {
    final patterns = _plurals[locale] ?? _plurals[const Locale('en')]!;
    final pattern = patterns[key] ?? patterns['items']!;
    
    // Simple implementation of ICU plural rules
    // In production, use proper ICU message formatting
    return pattern
        .replaceAll('{count}', count.toString())
        .replaceAll(RegExp(r'\{count, plural, .*?\}'), _resolvePlural(pattern, count, locale));
  }

  String _resolvePlural(String pattern, int count, Locale locale) {
    // Simplified plural rule resolution - in production use proper ICU
    if (count == 0 && pattern.contains('=0{')) {
      return _extractPluralForm(pattern, '=0');
    } else if (count == 1 && pattern.contains('=1{')) {
      return _extractPluralForm(pattern, '=1');
    } else if (count == 2 && pattern.contains('=2{')) {
      return _extractPluralForm(pattern, '=2');
    } else if (_isFew(count, locale) && pattern.contains('few{')) {
      return _extractPluralForm(pattern, 'few');
    } else if (_isMany(count, locale) && pattern.contains('many{')) {
      return _extractPluralForm(pattern, 'many');
    } else {
      return _extractPluralForm(pattern, 'other');
    }
  }

  String _extractPluralForm(String pattern, String form) {
    final regex = RegExp('$form\\{([^}]+)\\}');
    final match = regex.firstMatch(pattern);
    return match?.group(1)?.replaceAll('{count}', '') ?? '';
  }

  bool _isFew(int count, Locale locale) {
    switch (locale.languageCode) {
      case 'pl':
      case 'ru':
        return count % 10 >= 2 && count % 10 <= 4 && (count % 100 < 10 || count % 100 >= 20);
      case 'ar':
        return count >= 3 && count <= 10;
      default:
        return false;
    }
  }

  bool _isMany(int count, Locale locale) {
    switch (locale.languageCode) {
      case 'pl':
      case 'ru':
        return count != 1 && (count % 10 == 0 || count % 10 == 1 || (count % 10 >= 5 && count % 10 <= 9) || (count % 100 >= 11 && count % 100 <= 14));
      case 'ar':
        return count >= 11 && count <= 99;
      default:
        return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Pluralization Rules'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildLocaleInfo(locale),
            const SizedBox(height: 20),
            _buildPluralExample('Items', _itemCount, 'items', locale),
            const SizedBox(height: 20),
            _buildPluralExample('Messages', _messageCount, 'messages', locale),
            const SizedBox(height: 20),
            _buildPluralExample('People', _personCount, 'people', locale),
            const SizedBox(height: 20),
            _buildPluralRulesExplanation(locale),
          ],
        ),
      ),
    );
  }

  Widget _buildLocaleInfo(Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Current Language: ${_localeNames[locale]}',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            Text('Locale: ${locale.languageCode}'),
          ],
        ),
      ),
    );
  }

  Widget _buildPluralExample(String title, int count, String key, Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            Text(
              _formatPlural(locale, key, count),
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: count > 0 ? () {
                    setState(() {
                      if (key == 'items') _itemCount--;
                      else if (key == 'messages') _messageCount--;
                      else if (key == 'people') _personCount--;
                    });
                  } : null,
                  child: const Text('-'),
                ),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    '$count',
                    style: const TextStyle(fontSize: 24),
                  ),
                ),
                ElevatedButton(
                  onPressed: () {
                    setState(() {
                      if (key == 'items') _itemCount++;
                      else if (key == 'messages') _messageCount++;
                      else if (key == 'people') _personCount++;
                    });
                  },
                  child: const Text('+'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPluralRulesExplanation(Locale locale) {
    final explanations = {
      'en': 'English: Simple plural rules (1 = singular, other = plural)',
      'pl': 'Polish: Complex rules (1, 2-4, 5+ with special cases)',
      'ru': 'Russian: Similar to Polish with complex numeric rules',
      'ar': 'Arabic: Includes dual form (2) and different ranges',
      'cs': 'Czech: Complex Slavic plural rules',
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Plural Rules Explanation',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text(
              explanations[locale.languageCode] ?? explanations['en']!,
              style: const TextStyle(fontSize: 14),
            ),
            const SizedBox(height: 16),
            const Text(
              'Test different numbers to see how pluralization changes:',
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
            const Text(
              'Try: 0, 1, 2, 3, 4, 5, 11, 21, 22, 101, 102...',
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}
```

Pluralization rules vary dramatically between languages. English has simple  
singular/plural forms, while languages like Polish and Russian have complex  
rules based on number endings. Arabic includes dual forms, and some  
languages have up to six different plural categories. Proper pluralization  
ensures your app sounds natural to native speakers.

## Custom Localizations Delegate

Creating a custom localizations delegate for app-specific translations  
that aren't covered by standard Flutter localizations.  

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Custom Localizations',
      locale: _currentLocale,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
        Locale('ja'),
      ],
      home: CustomLocalizationsExample(onLocaleChange: _changeLocale),
    );
  }
}

class AppLocalizations {
  final Locale locale;

  AppLocalizations(this.locale);

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  static final Map<String, Map<String, String>> _localizedValues = {
    'en': {
      'app_name': 'My Application',
      'welcome_title': 'Welcome!',
      'welcome_message': 'Thanks for using our app',
      'login_button': 'Sign In',
      'logout_button': 'Sign Out',
      'settings_title': 'Settings',
      'profile_title': 'User Profile',
      'notifications_enabled': 'Notifications Enabled',
      'dark_mode': 'Dark Mode',
      'language': 'Language',
      'version': 'Version',
      'about': 'About',
      'privacy_policy': 'Privacy Policy',
      'terms_of_service': 'Terms of Service',
      'contact_support': 'Contact Support',
      'loading': 'Loading...',
      'error_occurred': 'An error occurred',
      'retry': 'Retry',
      'cancel': 'Cancel',
      'confirm': 'Confirm',
      'success': 'Success',
    },
    'es': {
      'app_name': 'Mi Aplicación',
      'welcome_title': '¡Bienvenido!',
      'welcome_message': 'Gracias por usar nuestra aplicación',
      'login_button': 'Iniciar Sesión',
      'logout_button': 'Cerrar Sesión',
      'settings_title': 'Configuración',
      'profile_title': 'Perfil de Usuario',
      'notifications_enabled': 'Notificaciones Habilitadas',
      'dark_mode': 'Modo Oscuro',
      'language': 'Idioma',
      'version': 'Versión',
      'about': 'Acerca de',
      'privacy_policy': 'Política de Privacidad',
      'terms_of_service': 'Términos de Servicio',
      'contact_support': 'Contactar Soporte',
      'loading': 'Cargando...',
      'error_occurred': 'Ocurrió un error',
      'retry': 'Reintentar',
      'cancel': 'Cancelar',
      'confirm': 'Confirmar',
      'success': 'Éxito',
    },
    'fr': {
      'app_name': 'Mon Application',
      'welcome_title': 'Bienvenue !',
      'welcome_message': 'Merci d\'utiliser notre application',
      'login_button': 'Se Connecter',
      'logout_button': 'Se Déconnecter',
      'settings_title': 'Paramètres',
      'profile_title': 'Profil Utilisateur',
      'notifications_enabled': 'Notifications Activées',
      'dark_mode': 'Mode Sombre',
      'language': 'Langue',
      'version': 'Version',
      'about': 'À Propos',
      'privacy_policy': 'Politique de Confidentialité',
      'terms_of_service': 'Conditions d\'Utilisation',
      'contact_support': 'Contacter le Support',
      'loading': 'Chargement...',
      'error_occurred': 'Une erreur s\'est produite',
      'retry': 'Réessayer',
      'cancel': 'Annuler',
      'confirm': 'Confirmer',
      'success': 'Succès',
    },
    'de': {
      'app_name': 'Meine Anwendung',
      'welcome_title': 'Willkommen!',
      'welcome_message': 'Danke, dass Sie unsere App verwenden',
      'login_button': 'Anmelden',
      'logout_button': 'Abmelden',
      'settings_title': 'Einstellungen',
      'profile_title': 'Benutzerprofil',
      'notifications_enabled': 'Benachrichtigungen Aktiviert',
      'dark_mode': 'Dunkler Modus',
      'language': 'Sprache',
      'version': 'Version',
      'about': 'Über',
      'privacy_policy': 'Datenschutzrichtlinie',
      'terms_of_service': 'Nutzungsbedingungen',
      'contact_support': 'Support Kontaktieren',
      'loading': 'Laden...',
      'error_occurred': 'Ein Fehler ist aufgetreten',
      'retry': 'Wiederholen',
      'cancel': 'Abbrechen',
      'confirm': 'Bestätigen',
      'success': 'Erfolg',
    },
    'ja': {
      'app_name': '私のアプリケーション',
      'welcome_title': 'ようこそ！',
      'welcome_message': 'アプリをご利用いただきありがとうございます',
      'login_button': 'サインイン',
      'logout_button': 'サインアウト',
      'settings_title': '設定',
      'profile_title': 'ユーザープロフィール',
      'notifications_enabled': '通知が有効',
      'dark_mode': 'ダークモード',
      'language': '言語',
      'version': 'バージョン',
      'about': 'について',
      'privacy_policy': 'プライバシーポリシー',
      'terms_of_service': '利用規約',
      'contact_support': 'サポートに連絡',
      'loading': '読み込み中...',
      'error_occurred': 'エラーが発生しました',
      'retry': '再試行',
      'cancel': 'キャンセル',
      'confirm': '確認',
      'success': '成功',
    },
  };

  String translate(String key) {
    return _localizedValues[locale.languageCode]?[key] ?? 
           _localizedValues['en']?[key] ?? 
           key;
  }

  // Convenience getters for commonly used strings
  String get appName => translate('app_name');
  String get welcomeTitle => translate('welcome_title');
  String get welcomeMessage => translate('welcome_message');
  String get loginButton => translate('login_button');
  String get logoutButton => translate('logout_button');
  String get settingsTitle => translate('settings_title');
  String get profileTitle => translate('profile_title');
  String get notificationsEnabled => translate('notifications_enabled');
  String get darkMode => translate('dark_mode');
  String get language => translate('language');
  String get version => translate('version');
  String get about => translate('about');
  String get privacyPolicy => translate('privacy_policy');
  String get termsOfService => translate('terms_of_service');
  String get contactSupport => translate('contact_support');
  String get loading => translate('loading');
  String get errorOccurred => translate('error_occurred');
  String get retry => translate('retry');
  String get cancel => translate('cancel');
  String get confirm => translate('confirm');
  String get success => translate('success');
}

class _AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'es', 'fr', 'de', 'ja'].contains(locale.languageCode);
  }

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(AppLocalizations(locale));
  }

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

class CustomLocalizationsExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const CustomLocalizationsExample({
    super.key,
    required this.onLocaleChange,
  });

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
    Locale('ja'): '🇯🇵 Japanese',
  };

  @override
  Widget build(BuildContext context) {
    final localizations = AppLocalizations.of(context)!;
    final currentLocale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.appName),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Row(
                    children: [
                      Text(entry.value),
                      if (entry.key.languageCode == currentLocale.languageCode) ...[
                        const Spacer(),
                        const Icon(Icons.check, color: Colors.green),
                      ],
                    ],
                  ),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildWelcomeCard(localizations),
            const SizedBox(height: 20),
            _buildActionsCard(localizations),
            const SizedBox(height: 20),
            _buildSettingsCard(localizations),
            const SizedBox(height: 20),
            _buildInfoCard(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildWelcomeCard(AppLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.welcomeTitle,
              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              localizations.welcomeMessage,
              style: const TextStyle(fontSize: 16),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionsCard(AppLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Actions',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: () {},
                  child: Text(localizations.loginButton),
                ),
                OutlinedButton(
                  onPressed: () {},
                  child: Text(localizations.logoutButton),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSettingsCard(AppLocalizations localizations) {
    return Card(
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              localizations.settingsTitle,
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.person),
            title: Text(localizations.profileTitle),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          SwitchListTile(
            secondary: const Icon(Icons.notifications),
            title: Text(localizations.notificationsEnabled),
            value: true,
            onChanged: (value) {},
          ),
          SwitchListTile(
            secondary: const Icon(Icons.dark_mode),
            title: Text(localizations.darkMode),
            value: false,
            onChanged: (value) {},
          ),
          ListTile(
            leading: const Icon(Icons.language),
            title: Text(localizations.language),
            subtitle: const Text('Current language settings'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
        ],
      ),
    );
  }

  Widget _buildInfoCard(AppLocalizations localizations) {
    return Card(
      child: Column(
        children: [
          ListTile(
            leading: const Icon(Icons.info),
            title: Text(localizations.about),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.privacy_tip),
            title: Text(localizations.privacyPolicy),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.description),
            title: Text(localizations.termsOfService),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.support_agent),
            title: Text(localizations.contactSupport),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.info_outline),
            title: Text('${localizations.version} 1.0.0'),
          ),
        ],
      ),
    );
  }
}
```

Custom localizations delegates provide complete control over your app's  
translations. Unlike ARB files, this approach allows for dynamic loading,  
complex logic, and runtime translation updates. The delegate pattern  
integrates seamlessly with Flutter's localization system while giving  
you flexibility to implement custom translation loading mechanisms.

## Locale-Aware Asset Loading

Loading different assets (images, fonts, sounds) based on the current  
locale to provide culturally appropriate content.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Locale-Aware Assets',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('es', 'ES'),
        Locale('ja', 'JP'),
        Locale('ar', 'SA'),
        Locale('de', 'DE'),
      ],
      home: AssetLocalizationExample(onLocaleChange: _changeLocale),
    );
  }
}

class AssetLocalizationExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const AssetLocalizationExample({
    super.key,
    required this.onLocaleChange,
  });

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English',
    Locale('es', 'ES'): '🇪🇸 Spanish',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('de', 'DE'): '🇩🇪 German',
  };

  // Asset paths for different locales
  static const Map<String, Map<String, String>> _assets = {
    'en': {
      'flag': 'assets/images/flags/us.png',
      'greeting': 'assets/images/greetings/hello_en.png',
      'currency': 'assets/images/currency/dollar.png',
      'font': 'Roboto',
      'culturalImage': 'assets/images/culture/american_flag.jpg',
    },
    'es': {
      'flag': 'assets/images/flags/spain.png',
      'greeting': 'assets/images/greetings/hola_es.png',
      'currency': 'assets/images/currency/euro.png',
      'font': 'Roboto',
      'culturalImage': 'assets/images/culture/spanish_culture.jpg',
    },
    'ja': {
      'flag': 'assets/images/flags/japan.png',
      'greeting': 'assets/images/greetings/konnichiwa_ja.png',
      'currency': 'assets/images/currency/yen.png',
      'font': 'NotoSansJP',
      'culturalImage': 'assets/images/culture/japanese_culture.jpg',
    },
    'ar': {
      'flag': 'assets/images/flags/saudi.png',
      'greeting': 'assets/images/greetings/marhaban_ar.png',
      'currency': 'assets/images/currency/riyal.png',
      'font': 'NotoSansArabic',
      'culturalImage': 'assets/images/culture/arabic_culture.jpg',
    },
    'de': {
      'flag': 'assets/images/flags/germany.png',
      'greeting': 'assets/images/greetings/hallo_de.png',
      'currency': 'assets/images/currency/euro.png',
      'font': 'Roboto',
      'culturalImage': 'assets/images/culture/german_culture.jpg',
    },
  };

  static const Map<String, Map<String, String>> _texts = {
    'en': {
      'title': 'Cultural Assets',
      'description': 'Assets change based on your locale',
      'flag_label': 'Country Flag',
      'greeting_label': 'Greeting Image',
      'currency_label': 'Currency Symbol',
      'font_label': 'Font Family',
      'cultural_label': 'Cultural Image',
    },
    'es': {
      'title': 'Activos Culturales',
      'description': 'Los recursos cambian según su configuración regional',
      'flag_label': 'Bandera del País',
      'greeting_label': 'Imagen de Saludo',
      'currency_label': 'Símbolo de Moneda',
      'font_label': 'Familia de Fuentes',
      'cultural_label': 'Imagen Cultural',
    },
    'ja': {
      'title': '文化的アセット',
      'description': 'ロケールに基づいてアセットが変更されます',
      'flag_label': '国旗',
      'greeting_label': '挨拶画像',
      'currency_label': '通貨記号',
      'font_label': 'フォントファミリー',
      'cultural_label': '文化的画像',
    },
    'ar': {
      'title': 'الأصول الثقافية',
      'description': 'تتغير الأصول بناءً على اللغة المحلية',
      'flag_label': 'علم الدولة',
      'greeting_label': 'صورة التحية',
      'currency_label': 'رمز العملة',
      'font_label': 'عائلة الخط',
      'cultural_label': 'صورة ثقافية',
    },
    'de': {
      'title': 'Kulturelle Assets',
      'description': 'Assets ändern sich basierend auf Ihrem Gebietsschema',
      'flag_label': 'Länderflagge',
      'greeting_label': 'Begrüßungsbild',
      'currency_label': 'Währungssymbol',
      'font_label': 'Schriftfamilie',
      'cultural_label': 'Kulturbild',
    },
  };

  String _getAssetPath(String assetType, String languageCode) {
    return _assets[languageCode]?[assetType] ?? 
           _assets['en']![assetType]!;
  }

  String _getText(String key, String languageCode) {
    return _texts[languageCode]?[key] ?? _texts['en']![key]!;
  }

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final languageCode = locale.languageCode;
    
    return Scaffold(
      appBar: AppBar(
        title: Text(_getText('title', languageCode)),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _getText('description', languageCode),
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 8),
                    Text('Current Locale: ${locale.toString()}'),
                    Text('Language: ${locale.languageCode}'),
                    Text('Country: ${locale.countryCode ?? "N/A"}'),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),
            _buildAssetCard(
              _getText('flag_label', languageCode),
              _getAssetPath('flag', languageCode),
              context,
            ),
            const SizedBox(height: 16),
            _buildAssetCard(
              _getText('greeting_label', languageCode),
              _getAssetPath('greeting', languageCode),
              context,
            ),
            const SizedBox(height: 16),
            _buildAssetCard(
              _getText('currency_label', languageCode),
              _getAssetPath('currency', languageCode),
              context,
            ),
            const SizedBox(height: 16),
            _buildFontCard(
              _getText('font_label', languageCode),
              _getAssetPath('font', languageCode),
              languageCode,
            ),
            const SizedBox(height: 16),
            _buildAssetCard(
              _getText('cultural_label', languageCode),
              _getAssetPath('culturalImage', languageCode),
              context,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAssetCard(String title, String assetPath, BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 12),
            Container(
              width: double.infinity,
              height: 120,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey[300]!),
                borderRadius: BorderRadius.circular(8),
                color: Colors.grey[100],
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.image,
                    size: 48,
                    color: Colors.grey[600],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Image would load from:',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                  Text(
                    assetPath,
                    style: TextStyle(
                      fontSize: 11,
                      fontFamily: 'monospace',
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFontCard(String title, String fontFamily, String languageCode) {
    final sampleTexts = {
      'en': 'The quick brown fox jumps over the lazy dog',
      'es': 'El rápido zorro marrón salta sobre el perro perezoso',
      'ja': 'すばやい茶色のキツネが怠惰な犬を飛び越える',
      'ar': 'الثعلب البني السريع يقفز فوق الكلب الكسول',
      'de': 'Der schnelle braune Fuchs springt über den faulen Hund',
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 12),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey[300]!),
                borderRadius: BorderRadius.circular(8),
                color: Colors.grey[50],
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Font Family: $fontFamily',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    sampleTexts[languageCode] ?? sampleTexts['en']!,
                    style: TextStyle(
                      fontFamily: fontFamily,
                      fontSize: 16,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

Locale-aware asset loading allows your app to display culturally  
appropriate content. This includes using region-specific images,  
appropriate fonts for different scripts, currency symbols, and  
cultural references that resonate with local users. The asset  
paths are dynamically selected based on the current locale.

## Context-Aware Translations

Implementing context-sensitive translations where the same word  
can have different meanings based on the usage context.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Context-Aware Translations',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
        Locale('ja'),
      ],
      home: ContextAwareExample(onLocaleChange: _changeLocale),
    );
  }
}

class ContextAwareExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const ContextAwareExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<ContextAwareExample> createState() => _ContextAwareExampleState();
}

class _ContextAwareExampleState extends State<ContextAwareExample> {
  String _selectedContext = 'general';

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish', 
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
    Locale('ja'): '🇯🇵 Japanese',
  };

  // Context-aware translations
  static const Map<String, Map<String, Map<String, String>>> _translations = {
    'en': {
      'close': {
        'general': 'Close',
        'door_window': 'Close (shut)',
        'relationship': 'Close (intimate)',
        'distance': 'Close (nearby)',
        'business': 'Close (end operations)',
        'computer': 'Close (application)',
      },
      'bank': {
        'general': 'Bank',
        'financial': 'Bank (financial institution)',
        'river': 'Bank (river side)',
        'savings': 'Bank (save money)',
        'memory': 'Bank (memory storage)',
      },
      'light': {
        'general': 'Light',
        'illumination': 'Light (brightness)',
        'weight': 'Light (not heavy)',
        'color': 'Light (pale color)',
        'fire': 'Light (ignite)',
        'easy': 'Light (easy task)',
      },
      'play': {
        'general': 'Play',
        'game': 'Play (game)',
        'music': 'Play (music)',
        'theater': 'Play (theater performance)',
        'sports': 'Play (sports)',
        'role': 'Play (act as)',
      },
    },
    'es': {
      'close': {
        'general': 'Cerrar',
        'door_window': 'Cerrar (puerta/ventana)',
        'relationship': 'Cercano (íntimo)',
        'distance': 'Cerca (proximidad)',
        'business': 'Cerrar (negocio)',
        'computer': 'Cerrar (aplicación)',
      },
      'bank': {
        'general': 'Banco',
        'financial': 'Banco (institución financiera)',
        'river': 'Orilla (del río)',
        'savings': 'Depositar (dinero)',
        'memory': 'Banco (de memoria)',
      },
      'light': {
        'general': 'Luz',
        'illumination': 'Luz (iluminación)',
        'weight': 'Ligero (peso)',
        'color': 'Claro (color)',
        'fire': 'Encender',
        'easy': 'Fácil (tarea)',
      },
      'play': {
        'general': 'Jugar',
        'game': 'Jugar (juego)',
        'music': 'Tocar (música)',
        'theater': 'Obra (de teatro)',
        'sports': 'Jugar (deportes)',
        'role': 'Interpretar (papel)',
      },
    },
    'fr': {
      'close': {
        'general': 'Fermer',
        'door_window': 'Fermer (porte/fenêtre)',
        'relationship': 'Proche (intime)',
        'distance': 'Proche (distance)',
        'business': 'Fermer (entreprise)',
        'computer': 'Fermer (application)',
      },
      'bank': {
        'general': 'Banque',
        'financial': 'Banque (institution financière)',
        'river': 'Rive (de rivière)',
        'savings': 'Déposer (argent)',
        'memory': 'Banque (mémoire)',
      },
      'light': {
        'general': 'Lumière',
        'illumination': 'Lumière (éclairage)',
        'weight': 'Léger (poids)',
        'color': 'Clair (couleur)',
        'fire': 'Allumer',
        'easy': 'Facile (tâche)',
      },
      'play': {
        'general': 'Jouer',
        'game': 'Jouer (jeu)',
        'music': 'Jouer (musique)',
        'theater': 'Pièce (de théâtre)',
        'sports': 'Jouer (sport)',
        'role': 'Jouer (rôle)',
      },
    },
  };

  String _getTranslation(String word, String context, String languageCode) {
    return _translations[languageCode]?[word]?[context] ?? 
           _translations['en']?[word]?[context] ?? 
           word;
  }

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final languageCode = locale.languageCode;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Context-Aware Translations'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildExplanationCard(),
            const SizedBox(height: 20),
            _buildContextSelector(),
            const SizedBox(height: 20),
            _buildTranslationExamples(languageCode),
          ],
        ),
      ),
    );
  }

  Widget _buildExplanationCard() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Context-Aware Translations',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            const Text(
              'The same word can have different meanings depending on the context. '
              'Select a context below to see how translations adapt.',
              style: TextStyle(fontSize: 14),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContextSelector() {
    final contexts = {
      'general': 'General Use',
      'door_window': 'Door/Window',
      'relationship': 'Relationship',
      'distance': 'Distance/Location',
      'business': 'Business',
      'computer': 'Computer/Technology',
      'financial': 'Financial',
      'river': 'Geography/Nature',
      'savings': 'Money/Savings',
      'memory': 'Technology/Memory',
      'illumination': 'Light/Brightness',
      'weight': 'Physical Weight',
      'color': 'Color/Appearance',
      'fire': 'Fire/Ignition',
      'easy': 'Difficulty Level',
      'game': 'Games/Recreation',
      'music': 'Music/Audio',
      'theater': 'Theater/Performance',
      'sports': 'Sports/Physical Activity',
      'role': 'Acting/Role Playing',
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Select Context',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 12),
            DropdownButtonFormField<String>(
              value: _selectedContext,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                contentPadding: EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
              ),
              items: contexts.entries.map((entry) {
                return DropdownMenuItem<String>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _selectedContext = value;
                  });
                }
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTranslationExamples(String languageCode) {
    final words = ['close', 'bank', 'light', 'play'];

    return Column(
      children: words.map((word) {
        final translation = _getTranslation(word, _selectedContext, languageCode);
        final isRelevant = _translations['en']?[word]?.containsKey(_selectedContext) ?? false;

        return Card(
          margin: const EdgeInsets.only(bottom: 12),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Text(
                      word.toUpperCase(),
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        letterSpacing: 1.2,
                      ),
                    ),
                    const Spacer(),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: isRelevant ? Colors.green[100] : Colors.grey[100],
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        isRelevant ? 'Contextual' : 'General',
                        style: TextStyle(
                          fontSize: 12,
                          color: isRelevant ? Colors.green[800] : Colors.grey[600],
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.blue[50],
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue[200]!),
                  ),
                  child: Text(
                    translation,
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
                if (isRelevant) ...[
                  const SizedBox(height: 8),
                  Text(
                    'Context-specific translation applied',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.green[700],
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                ] else ...[
                  const SizedBox(height: 8),
                  Text(
                    'Using general translation (context not applicable)',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                ],
              ],
            ),
          ),
        );
      }).toList(),
    );
  }
}
```

Context-aware translations recognize that many words have multiple meanings  
depending on their usage context. For example, "close" can mean shutting  
a door, being physically near, or ending business operations. This system  
maps contexts to appropriate translations, ensuring users see the most  
relevant meaning for each situation.

## Dynamic Translation Loading

Loading translations dynamically from remote servers or local files  
to enable real-time content updates without app store releases.  

```dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Dynamic Translations',
      locale: _currentLocale,
      localizationsDelegates: const [
        DynamicLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
      ],
      home: DynamicTranslationExample(onLocaleChange: _changeLocale),
    );
  }
}

class DynamicLocalizations {
  final Locale locale;
  Map<String, String> _translations = {};
  bool _isLoaded = false;

  DynamicLocalizations(this.locale);

  static DynamicLocalizations? of(BuildContext context) {
    return Localizations.of<DynamicLocalizations>(context, DynamicLocalizations);
  }

  Future<void> load() async {
    if (_isLoaded) return;
    
    try {
      // Simulate loading from remote server or local file
      final jsonString = await rootBundle.loadString(
        'assets/translations/${locale.languageCode}.json',
      );
      final Map<String, dynamic> jsonMap = json.decode(jsonString);
      
      _translations = Map<String, String>.from(jsonMap);
      _isLoaded = true;
    } catch (e) {
      // Fallback to embedded translations if file loading fails
      await _loadFallbackTranslations();
    }
  }

  Future<void> _loadFallbackTranslations() async {
    _translations = _getFallbackTranslations()[locale.languageCode] ?? 
                   _getFallbackTranslations()['en']!;
    _isLoaded = true;
  }

  Map<String, Map<String, String>> _getFallbackTranslations() {
    return {
      'en': {
        'app_title': 'Dynamic Translations',
        'loading': 'Loading translations...',
        'reload_button': 'Reload Translations',
        'status_loaded': 'Translations loaded successfully',
        'status_error': 'Error loading translations',
        'welcome_title': 'Welcome!',
        'welcome_message': 'This app loads translations dynamically',
        'feature_1': 'Real-time translation updates',
        'feature_2': 'No app store updates needed',
        'feature_3': 'Flexible content management',
        'last_updated': 'Last updated',
        'version': 'Translation version',
        'source': 'Translation source',
        'refresh': 'Refresh Content',
      },
      'es': {
        'app_title': 'Traducciones Dinámicas',
        'loading': 'Cargando traducciones...',
        'reload_button': 'Recargar Traducciones',
        'status_loaded': 'Traducciones cargadas exitosamente',
        'status_error': 'Error al cargar traducciones',
        'welcome_title': '¡Bienvenido!',
        'welcome_message': 'Esta aplicación carga traducciones dinámicamente',
        'feature_1': 'Actualizaciones de traducción en tiempo real',
        'feature_2': 'No se necesitan actualizaciones de la tienda de apps',
        'feature_3': 'Gestión de contenido flexible',
        'last_updated': 'Última actualización',
        'version': 'Versión de traducción',
        'source': 'Fuente de traducción',
        'refresh': 'Actualizar Contenido',
      },
      'fr': {
        'app_title': 'Traductions Dynamiques',
        'loading': 'Chargement des traductions...',
        'reload_button': 'Recharger les Traductions',
        'status_loaded': 'Traductions chargées avec succès',
        'status_error': 'Erreur lors du chargement des traductions',
        'welcome_title': 'Bienvenue !',
        'welcome_message': 'Cette app charge les traductions dynamiquement',
        'feature_1': 'Mises à jour de traduction en temps réel',
        'feature_2': 'Aucune mise à jour d\'app store nécessaire',
        'feature_3': 'Gestion de contenu flexible',
        'last_updated': 'Dernière mise à jour',
        'version': 'Version de traduction',
        'source': 'Source de traduction',
        'refresh': 'Actualiser le Contenu',
      },
      'de': {
        'app_title': 'Dynamische Übersetzungen',
        'loading': 'Lade Übersetzungen...',
        'reload_button': 'Übersetzungen Neu Laden',
        'status_loaded': 'Übersetzungen erfolgreich geladen',
        'status_error': 'Fehler beim Laden der Übersetzungen',
        'welcome_title': 'Willkommen!',
        'welcome_message': 'Diese App lädt Übersetzungen dynamisch',
        'feature_1': 'Echtzeit-Übersetzungsupda1tes',
        'feature_2': 'Keine App Store Updates erforderlich',
        'feature_3': 'Flexible Content-Verwaltung',
        'last_updated': 'Zuletzt aktualisiert',
        'version': 'Übersetzungsversion',
        'source': 'Übersetzungsquelle',
        'refresh': 'Inhalt Aktualisieren',
      },
    };
  }

  String translate(String key) {
    return _translations[key] ?? key;
  }

  bool get isLoaded => _isLoaded;

  Future<void> reload() async {
    _isLoaded = false;
    _translations.clear();
    await load();
  }
}

class DynamicLocalizationsDelegate extends LocalizationsDelegate<DynamicLocalizations> {
  const DynamicLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'es', 'fr', 'de'].contains(locale.languageCode);
  }

  @override
  Future<DynamicLocalizations> load(Locale locale) async {
    final localizations = DynamicLocalizations(locale);
    await localizations.load();
    return localizations;
  }

  @override
  bool shouldReload(DynamicLocalizationsDelegate old) => false;
}

class DynamicTranslationExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const DynamicTranslationExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<DynamicTranslationExample> createState() => _DynamicTranslationExampleState();
}

class _DynamicTranslationExampleState extends State<DynamicTranslationExample> {
  bool _isReloading = false;
  DateTime _lastUpdated = DateTime.now();

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
  };

  Future<void> _reloadTranslations() async {
    setState(() => _isReloading = true);
    
    try {
      final localizations = DynamicLocalizations.of(context);
      await localizations?.reload();
      setState(() {
        _lastUpdated = DateTime.now();
      });
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              localizations?.translate('status_loaded') ?? 'Translations reloaded'
            ),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              DynamicLocalizations.of(context)?.translate('status_error') ?? 
              'Error reloading translations'
            ),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isReloading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final localizations = DynamicLocalizations.of(context);
    final currentLocale = Localizations.localeOf(context);

    if (localizations == null || !localizations.isLoaded) {
      return Scaffold(
        appBar: AppBar(title: const Text('Loading...')),
        body: const Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Loading translations...'),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('app_title')),
        actions: [
          IconButton(
            icon: _isReloading 
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Icon(Icons.refresh),
            onPressed: _isReloading ? null : _reloadTranslations,
            tooltip: localizations.translate('refresh'),
          ),
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildWelcomeCard(localizations),
            const SizedBox(height: 20),
            _buildFeaturesCard(localizations),
            const SizedBox(height: 20),
            _buildStatusCard(localizations, currentLocale),
            const SizedBox(height: 20),
            _buildActionButton(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildWelcomeCard(DynamicLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('welcome_title'),
              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              localizations.translate('welcome_message'),
              style: const TextStyle(fontSize: 16),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFeaturesCard(DynamicLocalizations localizations) {
    final features = [
      localizations.translate('feature_1'),
      localizations.translate('feature_2'),
      localizations.translate('feature_3'),
    ];

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Features',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            ...features.map((feature) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.check_circle, color: Colors.green, size: 20),
                  const SizedBox(width: 8),
                  Expanded(child: Text(feature)),
                ],
              ),
            )),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusCard(DynamicLocalizations localizations, Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Translation Status',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildStatusRow(
              localizations.translate('version'),
              '1.0.0',
            ),
            _buildStatusRow(
              localizations.translate('source'),
              'Embedded fallback',
            ),
            _buildStatusRow(
              localizations.translate('last_updated'),
              '${_lastUpdated.hour}:${_lastUpdated.minute.toString().padLeft(2, '0')}',
            ),
            _buildStatusRow(
              'Locale',
              '${locale.languageCode.toUpperCase()} (${locale.languageCode})',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontFamily: 'monospace'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButton(DynamicLocalizations localizations) {
    return SizedBox(
      width: double.infinity,
      child: ElevatedButton.icon(
        onPressed: _isReloading ? null : _reloadTranslations,
        icon: _isReloading 
            ? const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : const Icon(Icons.refresh),
        label: Text(
          _isReloading 
              ? localizations.translate('loading')
              : localizations.translate('reload_button'),
        ),
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.all(16),
        ),
      ),
    );
  }
}
```

Dynamic translation loading enables real-time content updates without  
requiring app store releases. This approach is particularly valuable  
for frequently changing content, A/B testing translations, or making  
quick corrections. The system gracefully falls back to embedded  
translations if remote loading fails, ensuring app reliability.

## Locale-Aware Input Methods

Handling different input methods, keyboard layouts, and text input  
conventions for various languages and regions.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Locale-Aware Input Methods',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('ja', 'JP'),
        Locale('ar', 'SA'),
        Locale('hi', 'IN'),
        Locale('zh', 'CN'),
        Locale('ko', 'KR'),
        Locale('th', 'TH'),
        Locale('he', 'IL'),
      ],
      home: InputMethodExample(onLocaleChange: _changeLocale),
    );
  }
}

class InputMethodExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const InputMethodExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<InputMethodExample> createState() => _InputMethodExampleState();
}

class _InputMethodExampleState extends State<InputMethodExample> {
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, FocusNode> _focusNodes = {};

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('hi', 'IN'): '🇮🇳 Hindi',
    Locale('zh', 'CN'): '🇨🇳 Chinese',
    Locale('ko', 'KR'): '🇰🇷 Korean',
    Locale('th', 'TH'): '🇹🇭 Thai',
    Locale('he', 'IL'): '🇮🇱 Hebrew',
  };

  @override
  void initState() {
    super.initState();
    _initializeControllers();
  }

  @override
  void dispose() {
    _controllers.values.forEach((controller) => controller.dispose());
    _focusNodes.values.forEach((node) => node.dispose());
    super.dispose();
  }

  void _initializeControllers() {
    final fields = [
      'name', 'email', 'phone', 'address', 'search', 'multiline'
    ];
    
    for (final field in fields) {
      _controllers[field] = TextEditingController();
      _focusNodes[field] = FocusNode();
    }
  }

  TextInputType _getKeyboardType(String field, String languageCode) {
    switch (field) {
      case 'email':
        return TextInputType.emailAddress;
      case 'phone':
        return TextInputType.phone;
      case 'address':
        return TextInputType.streetAddress;
      case 'multiline':
        return TextInputType.multiline;
      case 'search':
        return TextInputType.text;
      default:
        // Different keyboard types based on language
        switch (languageCode) {
          case 'ja':
          case 'zh':
          case 'ko':
          case 'th':
          case 'hi':
            return TextInputType.text; // IME enabled automatically
          case 'ar':
          case 'he':
            return TextInputType.text; // RTL text input
          default:
            return TextInputType.name;
        }
    }
  }

  TextInputAction _getTextInputAction(String field) {
    switch (field) {
      case 'multiline':
        return TextInputAction.newline;
      case 'search':
        return TextInputAction.search;
      case 'address':
        return TextInputAction.done;
      default:
        return TextInputAction.next;
    }
  }

  List<TextInputFormatter> _getInputFormatters(String field, String languageCode) {
    switch (field) {
      case 'phone':
        return [
          FilteringTextInputFormatter.allow(RegExp(r'[\d\s\-\+\(\)]')),
          LengthLimitingTextInputFormatter(20),
        ];
      case 'email':
        return [
          FilteringTextInputFormatter.deny(RegExp(r'\s')),
          LengthLimitingTextInputFormatter(100),
        ];
      case 'name':
        switch (languageCode) {
          case 'ja':
          case 'zh':
          case 'ko':
          case 'th':
          case 'hi':
            return [LengthLimitingTextInputFormatter(50)];
          case 'ar':
          case 'he':
            return [
              LengthLimitingTextInputFormatter(50),
              // RTL languages may need special formatting
            ];
          default:
            return [
              FilteringTextInputFormatter.allow(RegExp(r'[a-zA-Z\s]')),
              LengthLimitingTextInputFormatter(50),
            ];
        }
      default:
        return [];
    }
  }

  String _getHintText(String field, String languageCode) {
    final hints = {
      'en': {
        'name': 'Enter your name',
        'email': 'Enter email address',
        'phone': 'Enter phone number',
        'address': 'Enter your address',
        'search': 'Search...',
        'multiline': 'Enter multiple lines of text',
      },
      'ja': {
        'name': '名前を入力してください',
        'email': 'メールアドレスを入力',
        'phone': '電話番号を入力',
        'address': '住所を入力してください',
        'search': '検索...',
        'multiline': '複数行のテキストを入力',
      },
      'ar': {
        'name': 'أدخل اسمك',
        'email': 'أدخل عنوان البريد الإلكتروني',
        'phone': 'أدخل رقم الهاتف',
        'address': 'أدخل عنوانك',
        'search': 'بحث...',
        'multiline': 'أدخل نص متعدد الأسطر',
      },
      'hi': {
        'name': 'अपना नाम दर्ज करें',
        'email': 'ईमेल पता दर्ज करें',
        'phone': 'फ़ोन नंबर दर्ज करें',
        'address': 'अपना पता दर्ज करें',
        'search': 'खोजें...',
        'multiline': 'बहु-पंक्ति पाठ दर्ज करें',
      },
      'zh': {
        'name': '输入您的姓名',
        'email': '输入电子邮件地址',
        'phone': '输入电话号码',
        'address': '输入您的地址',
        'search': '搜索...',
        'multiline': '输入多行文本',
      },
    };

    return hints[languageCode]?[field] ?? hints['en']![field]!;
  }

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final languageCode = locale.languageCode;
    final isRTL = Directionality.of(context) == TextDirection.rtl;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Input Methods'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildLocaleInfoCard(locale, isRTL),
            const SizedBox(height: 20),
            _buildInputForm(languageCode, isRTL),
            const SizedBox(height: 20),
            _buildInputMethodInfo(languageCode),
          ],
        ),
      ),
    );
  }

  Widget _buildLocaleInfoCard(Locale locale, bool isRTL) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Input Configuration',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text('Locale: ${locale.toString()}'),
            Text('Language: ${locale.languageCode}'),
            Text('Direction: ${isRTL ? "RTL" : "LTR"}'),
            Text('Script: ${_getScriptName(locale.languageCode)}'),
          ],
        ),
      ),
    );
  }

  String _getScriptName(String languageCode) {
    switch (languageCode) {
      case 'ar': return 'Arabic';
      case 'he': return 'Hebrew';
      case 'hi': return 'Devanagari';
      case 'ja': return 'Hiragana/Katakana/Kanji';
      case 'zh': return 'Chinese characters';
      case 'ko': return 'Hangul';
      case 'th': return 'Thai';
      default: return 'Latin';
    }
  }

  Widget _buildInputForm(String languageCode, bool isRTL) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Input Fields',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            ..._buildInputFields(languageCode, isRTL),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildInputFields(String languageCode, bool isRTL) {
    final fields = [
      {'key': 'name', 'label': 'Name', 'maxLines': 1},
      {'key': 'email', 'label': 'Email', 'maxLines': 1},
      {'key': 'phone', 'label': 'Phone', 'maxLines': 1},
      {'key': 'address', 'label': 'Address', 'maxLines': 1},
      {'key': 'search', 'label': 'Search', 'maxLines': 1},
      {'key': 'multiline', 'label': 'Notes', 'maxLines': 3},
    ];

    return fields.map((field) {
      final key = field['key'] as String;
      final label = field['label'] as String;
      final maxLines = field['maxLines'] as int;

      return Padding(
        padding: const EdgeInsets.only(bottom: 16.0),
        child: TextField(
          controller: _controllers[key],
          focusNode: _focusNodes[key],
          keyboardType: _getKeyboardType(key, languageCode),
          textInputAction: _getTextInputAction(key),
          inputFormatters: _getInputFormatters(key, languageCode),
          maxLines: maxLines,
          textDirection: isRTL ? TextDirection.rtl : TextDirection.ltr,
          decoration: InputDecoration(
            labelText: label,
            hintText: _getHintText(key, languageCode),
            border: const OutlineInputBorder(),
            suffixIcon: _getSuffixIcon(key),
          ),
          onSubmitted: (value) {
            // Handle different submit actions
            if (key == 'search') {
              _performSearch(value);
            } else {
              _focusNextField(key);
            }
          },
        ),
      );
    }).toList();
  }

  Widget? _getSuffixIcon(String key) {
    switch (key) {
      case 'search':
        return const Icon(Icons.search);
      case 'email':
        return const Icon(Icons.email);
      case 'phone':
        return const Icon(Icons.phone);
      case 'address':
        return const Icon(Icons.location_on);
      default:
        return null;
    }
  }

  void _focusNextField(String currentKey) {
    final fields = ['name', 'email', 'phone', 'address', 'search', 'multiline'];
    final currentIndex = fields.indexOf(currentKey);
    if (currentIndex >= 0 && currentIndex < fields.length - 1) {
      final nextKey = fields[currentIndex + 1];
      _focusNodes[nextKey]?.requestFocus();
    }
  }

  void _performSearch(String query) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Searching for: $query')),
    );
  }

  Widget _buildInputMethodInfo(String languageCode) {
    final info = _getInputMethodInfo(languageCode);
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Input Method Information',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 12),
            ...info.entries.map((entry) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                    width: 120,
                    child: Text(
                      '${entry.key}:',
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                  ),
                  Expanded(child: Text(entry.value)),
                ],
              ),
            )),
          ],
        ),
      ),
    );
  }

  Map<String, String> _getInputMethodInfo(String languageCode) {
    switch (languageCode) {
      case 'ja':
        return {
          'IME': 'Japanese Input Method',
          'Scripts': 'Hiragana, Katakana, Kanji',
          'Features': 'Automatic conversion, Predictive text',
          'Special Keys': 'Conversion, Selection',
        };
      case 'zh':
        return {
          'IME': 'Chinese Input Method',
          'Scripts': 'Simplified/Traditional Chinese',
          'Features': 'Pinyin, Stroke input, Predictive text',
          'Special Keys': 'Conversion, Character selection',
        };
      case 'ko':
        return {
          'IME': 'Korean Input Method',
          'Scripts': 'Hangul',
          'Features': 'Syllable composition, Predictive text',
          'Special Keys': 'Composition, Selection',
        };
      case 'ar':
        return {
          'IME': 'Arabic Input Method',
          'Scripts': 'Arabic script',
          'Features': 'RTL input, Contextual shaping',
          'Special Keys': 'Direction controls',
        };
      case 'hi':
        return {
          'IME': 'Hindi Input Method',
          'Scripts': 'Devanagari',
          'Features': 'Transliteration, Conjunct formation',
          'Special Keys': 'Vowel marks, Conjuncts',
        };
      case 'th':
        return {
          'IME': 'Thai Input Method',
          'Scripts': 'Thai script',
          'Features': 'Tone marks, Vowel positioning',
          'Special Keys': 'Tone marks, Special characters',
        };
      case 'he':
        return {
          'IME': 'Hebrew Input Method',
          'Scripts': 'Hebrew script',
          'Features': 'RTL input, Nikud support',
          'Special Keys': 'Direction controls, Vowel points',
        };
      default:
        return {
          'IME': 'Latin Input Method',
          'Scripts': 'Latin alphabet',
          'Features': 'Auto-correction, Suggestions',
          'Special Keys': 'Standard keyboard',
        };
    }
  }
}
```

Locale-aware input methods ensure that users can comfortably enter text  
in their native languages. This includes proper IME (Input Method Editor)  
support for Asian languages, RTL text input for Arabic and Hebrew,  
appropriate keyboard layouts, and locale-specific input validation.  
The system adapts input behavior to match user expectations.

## Locale Detection and Fallbacks

Automatically detecting user locale preferences and implementing  
intelligent fallback strategies when translations are unavailable.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'dart:io' show Platform;

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale? _currentLocale;

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Locale Detection',
      locale: _currentLocale,
      localeResolutionCallback: _localeResolutionCallback,
      localizationsDelegates: const [
        SmartLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('en', 'GB'),
        Locale('es', 'ES'),
        Locale('es', 'MX'),
        Locale('fr', 'FR'),
        Locale('de', 'DE'),
        Locale('pt', 'BR'),
        Locale('ja', 'JP'),
        Locale('zh', 'CN'),
        Locale('ru', 'RU'),
      ],
      home: LocaleDetectionExample(onLocaleChange: _changeLocale),
    );
  }

  Locale _localeResolutionCallback(
    List<Locale>? systemLocales,
    Iterable<Locale> supportedLocales,
  ) {
    // Custom locale resolution logic
    if (_currentLocale != null) {
      return _currentLocale!;
    }

    if (systemLocales == null || systemLocales.isEmpty) {
      return const Locale('en', 'US'); // Ultimate fallback
    }

    // Try exact match first (language + country)
    for (final systemLocale in systemLocales) {
      for (final supportedLocale in supportedLocales) {
        if (systemLocale.languageCode == supportedLocale.languageCode &&
            systemLocale.countryCode == supportedLocale.countryCode) {
          return supportedLocale;
        }
      }
    }

    // Try language match only
    for (final systemLocale in systemLocales) {
      for (final supportedLocale in supportedLocales) {
        if (systemLocale.languageCode == supportedLocale.languageCode) {
          return supportedLocale;
        }
      }
    }

    // Fallback to English if available
    final englishLocale = supportedLocales.firstWhere(
      (locale) => locale.languageCode == 'en',
      orElse: () => supportedLocales.first,
    );

    return englishLocale;
  }
}

class SmartLocalizations {
  final Locale locale;

  SmartLocalizations(this.locale);

  static SmartLocalizations? of(BuildContext context) {
    return Localizations.of<SmartLocalizations>(context, SmartLocalizations);
  }

  // Available translations with fallback chain
  static final Map<String, Map<String, String>> _translations = {
    'en_US': {
      'app_title': 'Locale Detection',
      'system_locale': 'System Locale',
      'current_locale': 'Current Locale',
      'fallback_used': 'Fallback Used',
      'translation_quality': 'Translation Quality',
      'detection_method': 'Detection Method',
      'region_specific': 'Region-specific content available',
      'partial_translation': 'Partial translation available',
      'machine_translated': 'Machine translated content',
      'native_speaker': 'Native speaker verified',
    },
    'en_GB': {
      'app_title': 'Locale Detection',
      'system_locale': 'System Locale',
      'current_locale': 'Current Locale',
      'fallback_used': 'Fallback Used',
      'translation_quality': 'Translation Quality',
      'detection_method': 'Detection Method',
      'region_specific': 'Region-specific content available',
      'partial_translation': 'Partial translation available',
      'machine_translated': 'Machine translated content',
      'native_speaker': 'Native speaker verified',
    },
    'es_ES': {
      'app_title': 'Detección de Idioma',
      'system_locale': 'Configuración Regional del Sistema',
      'current_locale': 'Configuración Regional Actual',
      'fallback_used': 'Respaldo Utilizado',
      'translation_quality': 'Calidad de Traducción',
      'detection_method': 'Método de Detección',
      'region_specific': 'Contenido específico de región disponible',
      'partial_translation': 'Traducción parcial disponible',
      'machine_translated': 'Contenido traducido automáticamente',
      'native_speaker': 'Verificado por hablante nativo',
    },
    'es_MX': {
      'app_title': 'Detección de Idioma',
      'system_locale': 'Configuración Regional del Sistema',
      'current_locale': 'Configuración Regional Actual',
      'region_specific': 'Contenido específico de México disponible',
      // Partial translation - will fall back for missing keys
    },
    'fr_FR': {
      'app_title': 'Détection de Langue',
      'system_locale': 'Paramètres Régionaux Système',
      'current_locale': 'Paramètres Régionaux Actuels',
      // Minimal translation - will use fallbacks
    },
    'de_DE': {
      // Empty - will use complete fallback chain
    },
  };

  String _getTranslation(String key) {
    final localeKey = '${locale.languageCode}_${locale.countryCode}';
    
    // Try exact locale match
    if (_translations[localeKey]?.containsKey(key) == true) {
      return _translations[localeKey]![key]!;
    }

    // Try language-only match
    final languageKey = locale.languageCode;
    final languageMatch = _translations.keys
        .where((k) => k.startsWith('${languageKey}_'))
        .firstWhere(
          (k) => _translations[k]?.containsKey(key) == true,
          orElse: () => '',
        );
    
    if (languageMatch.isNotEmpty) {
      return _translations[languageMatch]![key]!;
    }

    // Fall back to English
    if (_translations['en_US']?.containsKey(key) == true) {
      return _translations['en_US']![key]!;
    }

    // Ultimate fallback
    return '[$key]';
  }

  FallbackInfo _getFallbackInfo(String key) {
    final localeKey = '${locale.languageCode}_${locale.countryCode}';
    
    if (_translations[localeKey]?.containsKey(key) == true) {
      return FallbackInfo(
        level: FallbackLevel.exact,
        source: localeKey,
        quality: TranslationQuality.native,
      );
    }

    final languageKey = locale.languageCode;
    final languageMatch = _translations.keys
        .where((k) => k.startsWith('${languageKey}_'))
        .firstWhere(
          (k) => _translations[k]?.containsKey(key) == true,
          orElse: () => '',
        );
    
    if (languageMatch.isNotEmpty) {
      return FallbackInfo(
        level: FallbackLevel.language,
        source: languageMatch,
        quality: TranslationQuality.partial,
      );
    }

    if (_translations['en_US']?.containsKey(key) == true) {
      return FallbackInfo(
        level: FallbackLevel.english,
        source: 'en_US',
        quality: TranslationQuality.fallback,
      );
    }

    return FallbackInfo(
      level: FallbackLevel.missing,
      source: 'none',
      quality: TranslationQuality.missing,
    );
  }

  String translate(String key) => _getTranslation(key);
  FallbackInfo getFallbackInfo(String key) => _getFallbackInfo(key);
}

enum FallbackLevel { exact, language, english, missing }
enum TranslationQuality { native, partial, fallback, missing }

class FallbackInfo {
  final FallbackLevel level;
  final String source;
  final TranslationQuality quality;

  FallbackInfo({
    required this.level,
    required this.source,
    required this.quality,
  });
}

class SmartLocalizationsDelegate extends LocalizationsDelegate<SmartLocalizations> {
  const SmartLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) => true; // Support all locales

  @override
  Future<SmartLocalizations> load(Locale locale) async {
    return SmartLocalizations(locale);
  }

  @override
  bool shouldReload(SmartLocalizationsDelegate old) => false;
}

class LocaleDetectionExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const LocaleDetectionExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  Widget build(BuildContext context) {
    final localizations = SmartLocalizations.of(context)!;
    final currentLocale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('app_title')),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              // Trigger locale re-detection
              onLocaleChange(const Locale('auto'));
            },
            tooltip: 'Re-detect locale',
          ),
          _buildLocaleSelector(context),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSystemInfo(context),
            const SizedBox(height: 20),
            _buildCurrentLocaleInfo(currentLocale, localizations),
            const SizedBox(height: 20),
            _buildFallbackDemo(localizations),
            const SizedBox(height: 20),
            _buildQualityIndicators(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildSystemInfo(BuildContext context) {
    final systemLocales = WidgetsBinding.instance.platformDispatcher.locales;
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'System Information',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            Text('Platform: ${Platform.operatingSystem}'),
            Text('System Locales: ${systemLocales.length} detected'),
            const SizedBox(height: 8),
            ...systemLocales.take(3).map((locale) => Padding(
              padding: const EdgeInsets.only(left: 16.0, top: 2.0),
              child: Text('• ${locale.toString()}'),
            )),
            if (systemLocales.length > 3)
              Padding(
                padding: const EdgeInsets.only(left: 16.0, top: 2.0),
                child: Text('• ... and ${systemLocales.length - 3} more'),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCurrentLocaleInfo(Locale locale, SmartLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('current_locale'),
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildInfoRow('Language', locale.languageCode.toUpperCase()),
            _buildInfoRow('Country', locale.countryCode ?? 'N/A'),
            _buildInfoRow('Full Code', locale.toString()),
            _buildInfoRow('Script', locale.scriptCode ?? 'Default'),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2.0),
      child: Row(
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Text(value),
        ],
      ),
    );
  }

  Widget _buildFallbackDemo(SmartLocalizations localizations) {
    final demoKeys = [
      'app_title',
      'region_specific',
      'partial_translation',
      'machine_translated',
      'missing_key_example',
    ];

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Fallback Demonstration',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            ...demoKeys.map((key) => _buildFallbackExample(key, localizations)),
          ],
        ),
      ),
    );
  }

  Widget _buildFallbackExample(String key, SmartLocalizations localizations) {
    final fallbackInfo = localizations.getFallbackInfo(key);
    final translation = localizations.translate(key);
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: Text(
                  translation,
                  style: const TextStyle(fontSize: 16),
                ),
              ),
              _buildQualityBadge(fallbackInfo.quality),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            'Source: ${fallbackInfo.source} (${fallbackInfo.level.name})',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildQualityBadge(TranslationQuality quality) {
    final colors = {
      TranslationQuality.native: Colors.green,
      TranslationQuality.partial: Colors.orange,
      TranslationQuality.fallback: Colors.blue,
      TranslationQuality.missing: Colors.red,
    };

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: colors[quality],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        quality.name.toUpperCase(),
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  Widget _buildQualityIndicators(SmartLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('translation_quality'),
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildQualityLegend(),
          ],
        ),
      ),
    );
  }

  Widget _buildQualityLegend() {
    final qualities = [
      {'quality': TranslationQuality.native, 'description': 'Native translation available'},
      {'quality': TranslationQuality.partial, 'description': 'Partial translation, some fallbacks'},
      {'quality': TranslationQuality.fallback, 'description': 'Using fallback language'},
      {'quality': TranslationQuality.missing, 'description': 'Translation missing'},
    ];

    return Column(
      children: qualities.map((item) {
        final quality = item['quality'] as TranslationQuality;
        final description = item['description'] as String;
        
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 4.0),
          child: Row(
            children: [
              _buildQualityBadge(quality),
              const SizedBox(width: 8),
              Expanded(child: Text(description)),
            ],
          ),
        );
      }).toList(),
    );
  }

  Widget _buildLocaleSelector(BuildContext context) {
    final supportedLocales = [
      const Locale('en', 'US'),
      const Locale('en', 'GB'),
      const Locale('es', 'ES'),
      const Locale('es', 'MX'),
      const Locale('fr', 'FR'),
      const Locale('de', 'DE'),
      const Locale('pt', 'BR'),
      const Locale('ja', 'JP'),
    ];

    return PopupMenuButton<Locale>(
      icon: const Icon(Icons.language),
      onSelected: onLocaleChange,
      itemBuilder: (context) {
        return supportedLocales.map((locale) {
          return PopupMenuItem<Locale>(
            value: locale,
            child: Text('${locale.languageCode}-${locale.countryCode}'),
          );
        }).toList();
      },
    );
  }
}
```

Locale detection and fallbacks ensure your app works gracefully across  
different regions and languages. The system attempts exact locale matches  
first, then falls back to language-only matches, and finally to a default  
language. Quality indicators help developers understand which translations  
need improvement, while users get the best available experience.

## Time Zone and Regional Settings

Handling time zones, regional date/time preferences, and locale-specific  
calendar systems for global applications.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';
import 'dart:io' show Platform;

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Time Zone & Regional Settings',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('en', 'GB'),
        Locale('ja', 'JP'),
        Locale('de', 'DE'),
        Locale('ar', 'SA'),
        Locale('hi', 'IN'),
        Locale('zh', 'CN'),
        Locale('es', 'ES'),
      ],
      home: TimeZoneExample(onLocaleChange: _changeLocale),
    );
  }
}

class TimeZoneExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const TimeZoneExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<TimeZoneExample> createState() => _TimeZoneExampleState();
}

class _TimeZoneExampleState extends State<TimeZoneExample> {
  DateTime _selectedDateTime = DateTime.now();
  String _selectedTimeZone = 'Local';

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 US English',
    Locale('en', 'GB'): '🇬🇧 UK English',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('de', 'DE'): '🇩🇪 German',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('hi', 'IN'): '🇮🇳 Hindi',
    Locale('zh', 'CN'): '🇨🇳 Chinese',
    Locale('es', 'ES'): '🇪🇸 Spanish',
  };

  static const Map<String, int> _timeZones = {
    'Local': 0, // Will be calculated
    'UTC': 0,
    'New York (EST/EDT)': -5,
    'London (GMT/BST)': 0,
    'Berlin (CET/CEST)': 1,
    'Tokyo (JST)': 9,
    'Sydney (AEST/AEDT)': 10,
    'Mumbai (IST)': 5,
    'Dubai (GST)': 4,
    'Beijing (CST)': 8,
    'Los Angeles (PST/PDT)': -8,
    'São Paulo (BRT)': -3,
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Time Zone & Regional Settings'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSystemTimeInfo(),
            const SizedBox(height: 20),
            _buildDateTimeSelector(),
            const SizedBox(height: 20),
            _buildTimeZoneSelector(),
            const SizedBox(height: 20),
            _buildRegionalFormats(locale),
            const SizedBox(height: 20),
            _buildCalendarInfo(locale),
            const SizedBox(height: 20),
            _buildWorkingHours(locale),
          ],
        ),
      ),
    );
  }

  Widget _buildSystemTimeInfo() {
    final now = DateTime.now();
    final utcNow = now.toUtc();
    final offset = now.timeZoneOffset;
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'System Time Information',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildTimeRow('Local Time', now.toString()),
            _buildTimeRow('UTC Time', utcNow.toString()),
            _buildTimeRow('Time Zone Offset', 
                '${offset.isNegative ? '' : '+'}${offset.inHours}:${(offset.inMinutes % 60).toString().padLeft(2, '0')}'),
            _buildTimeRow('Time Zone Name', now.timeZoneName),
            _buildTimeRow('Platform', Platform.operatingSystem),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 140,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontFamily: 'monospace'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDateTimeSelector() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Select Date & Time',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.calendar_today),
                    label: Text(DateFormat.yMd().format(_selectedDateTime)),
                    onPressed: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: _selectedDateTime,
                        firstDate: DateTime(2020),
                        lastDate: DateTime(2030),
                      );
                      if (date != null) {
                        setState(() {
                          _selectedDateTime = DateTime(
                            date.year,
                            date.month,
                            date.day,
                            _selectedDateTime.hour,
                            _selectedDateTime.minute,
                          );
                        });
                      }
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.access_time),
                    label: Text(DateFormat.jm().format(_selectedDateTime)),
                    onPressed: () async {
                      final time = await showTimePicker(
                        context: context,
                        initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
                      );
                      if (time != null) {
                        setState(() {
                          _selectedDateTime = DateTime(
                            _selectedDateTime.year,
                            _selectedDateTime.month,
                            _selectedDateTime.day,
                            time.hour,
                            time.minute,
                          );
                        });
                      }
                    },
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeZoneSelector() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Time Zone Selection',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _selectedTimeZone,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                labelText: 'Time Zone',
              ),
              items: _timeZones.keys.map((tz) {
                return DropdownMenuItem<String>(
                  value: tz,
                  child: Text(tz),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() => _selectedTimeZone = value);
                }
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRegionalFormats(Locale locale) {
    final adjustedTime = _getAdjustedTime();
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Regional Formats (${locale.toString()})',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildFormatSection('Date Formats', [
              ('Short', DateFormat.yMd(locale.toString()).format(adjustedTime)),
              ('Medium', DateFormat.yMMMd(locale.toString()).format(adjustedTime)),
              ('Long', DateFormat.yMMMMd(locale.toString()).format(adjustedTime)),
              ('Full', DateFormat.yMMMMEEEEd(locale.toString()).format(adjustedTime)),
            ]),
            const SizedBox(height: 16),
            _buildFormatSection('Time Formats', [
              ('12-hour', DateFormat.jm(locale.toString()).format(adjustedTime)),
              ('24-hour', DateFormat.Hm(locale.toString()).format(adjustedTime)),
              ('With seconds', DateFormat.jms(locale.toString()).format(adjustedTime)),
              ('Full', DateFormat.jmv(locale.toString()).format(adjustedTime)),
            ]),
            const SizedBox(height: 16),
            _buildFormatSection('Combined Formats', [
              ('Short', DateFormat.yMd(locale.toString()).add_jm().format(adjustedTime)),
              ('Medium', DateFormat.yMMMd(locale.toString()).add_jm().format(adjustedTime)),
              ('ISO 8601', adjustedTime.toIso8601String()),
              ('RFC 2822', DateFormat('EEE, dd MMM yyyy HH:mm:ss zzz').format(adjustedTime)),
            ]),
          ],
        ),
      ),
    );
  }

  DateTime _getAdjustedTime() {
    if (_selectedTimeZone == 'Local') {
      return _selectedDateTime;
    } else if (_selectedTimeZone == 'UTC') {
      return _selectedDateTime.toUtc();
    } else {
      final offset = _timeZones[_selectedTimeZone] ?? 0;
      return _selectedDateTime.add(Duration(hours: offset));
    }
  }

  Widget _buildFormatSection(String title, List<(String, String)> formats) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        ...formats.map((format) => Padding(
          padding: const EdgeInsets.symmetric(vertical: 2.0),
          child: Row(
            children: [
              SizedBox(
                width: 80,
                child: Text(
                  '${format.$1}:',
                  style: const TextStyle(fontSize: 14),
                ),
              ),
              Expanded(
                child: Text(
                  format.$2,
                  style: const TextStyle(
                    fontFamily: 'monospace',
                    fontSize: 14,
                  ),
                ),
              ),
            ],
          ),
        )),
      ],
    );
  }

  Widget _buildCalendarInfo(Locale locale) {
    final now = DateTime.now();
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Calendar Information',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildCalendarRow('Calendar System', _getCalendarSystem(locale)),
            _buildCalendarRow('First Day of Week', _getFirstDayOfWeek(locale)),
            _buildCalendarRow('Weekend Days', _getWeekendDays(locale)),
            _buildCalendarRow('Current Week', 'Week ${_getWeekOfYear(now)}'),
            _buildCalendarRow('Current Quarter', 'Q${_getQuarter(now)}'),
            if (_isLunarCalendarRelevant(locale))
              _buildCalendarRow('Lunar Calendar', _getLunarInfo(locale)),
          ],
        ),
      ),
    );
  }

  Widget _buildCalendarRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 140,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(child: Text(value)),
        ],
      ),
    );
  }

  String _getCalendarSystem(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return 'Hijri (Islamic) / Gregorian';
      case 'hi':
        return 'Hindu / Gregorian';
      case 'ja':
        return 'Japanese (Gregorian with Era)';
      case 'zh':
        return 'Chinese Traditional / Gregorian';
      default:
        return 'Gregorian';
    }
  }

  String _getFirstDayOfWeek(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
      case 'hi':
        return 'Saturday';
      case 'en':
        return locale.countryCode == 'US' ? 'Sunday' : 'Monday';
      default:
        return 'Monday';
    }
  }

  String _getWeekendDays(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return 'Friday - Saturday';
      case 'hi':
        return 'Saturday - Sunday (varies by region)';
      default:
        return 'Saturday - Sunday';
    }
  }

  int _getWeekOfYear(DateTime date) {
    final firstDayOfYear = DateTime(date.year, 1, 1);
    final daysDifference = date.difference(firstDayOfYear).inDays;
    return (daysDifference / 7).ceil();
  }

  int _getQuarter(DateTime date) {
    return ((date.month - 1) / 3).floor() + 1;
  }

  bool _isLunarCalendarRelevant(Locale locale) {
    return ['zh', 'ar', 'hi'].contains(locale.languageCode);
  }

  String _getLunarInfo(Locale locale) {
    switch (locale.languageCode) {
      case 'zh':
        return 'Chinese New Year calendar relevant';
      case 'ar':
        return 'Hijri calendar for religious dates';
      case 'hi':
        return 'Hindu lunar calendar for festivals';
      default:
        return 'Not applicable';
    }
  }

  Widget _buildWorkingHours(Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Regional Business Practices',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildBusinessRow('Standard Work Week', _getWorkWeek(locale)),
            _buildBusinessRow('Typical Work Hours', _getWorkHours(locale)),
            _buildBusinessRow('Lunch Break', _getLunchBreak(locale)),
            _buildBusinessRow('Business Holidays', _getBusinessHolidays(locale)),
            _buildBusinessRow('Cultural Notes', _getCulturalNotes(locale)),
          ],
        ),
      ),
    );
  }

  Widget _buildBusinessRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label:',
            style: const TextStyle(fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 2),
          Padding(
            padding: const EdgeInsets.only(left: 16.0),
            child: Text(
              value,
              style: const TextStyle(fontSize: 14),
            ),
          ),
          const SizedBox(height: 8),
        ],
      ),
    );
  }

  String _getWorkWeek(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return 'Sunday - Thursday (5 days)';
      case 'hi':
        return 'Monday - Saturday (6 days, half day Saturday)';
      default:
        return 'Monday - Friday (5 days)';
    }
  }

  String _getWorkHours(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return '8:00 AM - 5:00 PM (may vary during Ramadan)';
      case 'hi':
        return '9:30 AM - 6:30 PM (varies by region)';
      case 'ja':
        return '9:00 AM - 6:00 PM (overtime culture common)';
      case 'de':
        return '8:00 AM - 5:00 PM (strict work-life balance)';
      case 'es':
        return '9:00 AM - 2:00 PM, 4:00 PM - 7:00 PM (siesta break)';
      default:
        return '9:00 AM - 5:00 PM';
    }
  }

  String _getLunchBreak(Locale locale) {
    switch (locale.languageCode) {
      case 'es':
        return '2:00 PM - 4:00 PM (long siesta break)';
      case 'hi':
        return '1:00 PM - 2:00 PM (varies by region)';
      case 'ja':
        return '12:00 PM - 1:00 PM (often shorter)';
      default:
        return '12:00 PM - 1:00 PM';
    }
  }

  String _getBusinessHolidays(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return 'Eid al-Fitr, Eid al-Adha, Islamic New Year';
      case 'hi':
        return 'Diwali, Holi, Dussehra, regional festivals';
      case 'ja':
        return 'Golden Week, Obon, New Year (extended)';
      case 'zh':
        return 'Chinese New Year, National Day Golden Week';
      case 'de':
        return 'Christmas markets season, extensive summer holidays';
      default:
        return 'Christmas, New Year, national holidays';
    }
  }

  String _getCulturalNotes(Locale locale) {
    switch (locale.languageCode) {
      case 'ar':
        return 'Prayer times affect scheduling, Ramadan work hours';
      case 'hi':
        return 'Festival seasons impact business, regional variations';
      case 'ja':
        return 'Respect for hierarchy, consensus decision-making';
      case 'de':
        return 'Punctuality essential, direct communication style';
      case 'es':
        return 'Relationship-building important, flexible timing';
      default:
        return 'Standard business etiquette applies';
    }
  }
}
```

Time zone and regional settings handling ensures your app respects local  
customs and expectations. This includes proper time zone conversions,  
locale-appropriate date/time formats, awareness of different calendar  
systems, and understanding regional business practices. These considerations  
are crucial for apps serving global audiences.

## Multi-Language Content Management

Managing and organizing multilingual content with version control,  
translation workflows, and content synchronization.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'dart:convert';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Content Management',
      locale: _currentLocale,
      localizationsDelegates: const [
        ContentManagerDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
        Locale('ja'),
        Locale('ar'),
      ],
      home: ContentManagementExample(onLocaleChange: _changeLocale),
    );
  }
}

class ContentEntry {
  final String key;
  final Map<String, ContentVersion> versions;
  final ContentType type;
  final DateTime created;
  final DateTime lastModified;

  ContentEntry({
    required this.key,
    required this.versions,
    required this.type,
    required this.created,
    required this.lastModified,
  });
}

class ContentVersion {
  final String content;
  final String author;
  final DateTime timestamp;
  final TranslationStatus status;
  final String version;
  final List<String> tags;

  ContentVersion({
    required this.content,
    required this.author,
    required this.timestamp,
    required this.status,
    required this.version,
    this.tags = const [],
  });
}

enum ContentType { text, html, markdown, json }
enum TranslationStatus { draft, review, approved, published, outdated }

class ContentManager {
  final Locale locale;
  static final Map<String, ContentEntry> _content = _initializeContent();

  ContentManager(this.locale);

  static ContentManager? of(BuildContext context) {
    return Localizations.of<ContentManager>(context, ContentManager);
  }

  String getContent(String key, {ContentType type = ContentType.text}) {
    final entry = _content[key];
    if (entry == null) return '[$key]';

    // Try exact locale match
    final localeKey = locale.toString();
    final languageKey = locale.languageCode;

    ContentVersion? version = entry.versions[localeKey] ?? 
                             entry.versions[languageKey] ??
                             entry.versions['en'];

    if (version == null) return '[$key]';

    switch (type) {
      case ContentType.text:
        return _stripHtml(version.content);
      case ContentType.html:
        return version.content;
      case ContentType.markdown:
        return _convertToMarkdown(version.content);
      case ContentType.json:
        return _formatAsJson(version.content);
    }
  }

  ContentEntry? getContentEntry(String key) => _content[key];

  List<String> getAvailableLanguages(String key) {
    final entry = _content[key];
    if (entry == null) return [];
    return entry.versions.keys.toList();
  }

  TranslationStatus getTranslationStatus(String key) {
    final entry = _content[key];
    if (entry == null) return TranslationStatus.draft;

    final version = entry.versions[locale.languageCode];
    return version?.status ?? TranslationStatus.draft;
  }

  static Map<String, ContentEntry> _initializeContent() {
    return {
      'app_welcome': ContentEntry(
        key: 'app_welcome',
        type: ContentType.html,
        created: DateTime.now().subtract(const Duration(days: 30)),
        lastModified: DateTime.now().subtract(const Duration(days: 5)),
        versions: {
          'en': ContentVersion(
            content: '<h2>Welcome to our Application</h2><p>Discover amazing features and <strong>seamless experiences</strong> designed just for you.</p>',
            author: 'content-team@company.com',
            timestamp: DateTime.now().subtract(const Duration(days: 5)),
            status: TranslationStatus.published,
            version: '2.1.0',
            tags: ['homepage', 'welcome', 'featured'],
          ),
          'es': ContentVersion(
            content: '<h2>Bienvenido a nuestra Aplicación</h2><p>Descubre características increíbles y <strong>experiencias perfectas</strong> diseñadas solo para ti.</p>',
            author: 'translation-team@company.com',
            timestamp: DateTime.now().subtract(const Duration(days: 2)),
            status: TranslationStatus.approved,
            version: '2.1.0',
            tags: ['homepage', 'welcome', 'featured'],
          ),
          'fr': ContentVersion(
            content: '<h2>Bienvenue dans notre Application</h2><p>Découvrez des fonctionnalités incroyables et des <strong>expériences fluides</strong> conçues juste pour vous.</p>',
            author: 'translation-team@company.com',
            timestamp: DateTime.now().subtract(const Duration(days: 3)),
            status: TranslationStatus.review,
            version: '2.0.0',
            tags: ['homepage', 'welcome'],
          ),
          'de': ContentVersion(
            content: '<h2>Willkommen in unserer Anwendung</h2><p>Entdecken Sie erstaunliche Funktionen und <strong>nahtlose Erfahrungen</strong>, die nur für Sie entwickelt wurden.</p>',
            author: 'freelance-translator@example.com',
            timestamp: DateTime.now().subtract(const Duration(days: 10)),
            status: TranslationStatus.outdated,
            version: '1.9.0',
            tags: ['homepage', 'welcome'],
          ),
        },
      ),
      'feature_description': ContentEntry(
        key: 'feature_description',
        type: ContentType.markdown,
        created: DateTime.now().subtract(const Duration(days: 20)),
        lastModified: DateTime.now().subtract(const Duration(days: 1)),
        versions: {
          'en': ContentVersion(
            content: '## Key Features\n\n* **Smart Analytics**: Get insights into your usage patterns\n* **Real-time Sync**: Keep your data synchronized across all devices\n* **Advanced Security**: Your privacy is our top priority\n\n> *Experience the next generation of mobile applications.*',
            author: 'product-manager@company.com',
            timestamp: DateTime.now().subtract(const Duration(days: 1)),
            status: TranslationStatus.published,
            version: '1.0.0',
            tags: ['features', 'description'],
          ),
          'es': ContentVersion(
            content: '## Características Principales\n\n* **Análisis Inteligente**: Obtén información sobre tus patrones de uso\n* **Sincronización en Tiempo Real**: Mantén tus datos sincronizados en todos los dispositivos\n* **Seguridad Avanzada**: Tu privacidad es nuestra máxima prioridad\n\n> *Experimenta la próxima generación de aplicaciones móviles.*',
            author: 'translation-team@company.com',
            timestamp: DateTime.now().subtract(const Duration(hours: 12)),
            status: TranslationStatus.draft,
            version: '1.0.0',
            tags: ['features', 'description'],
          ),
          'ja': ContentVersion(
            content: '## 主な機能\n\n* **スマート分析**: 使用パターンの洞察を得る\n* **リアルタイム同期**: すべてのデバイスでデータを同期\n* **高度なセキュリティ**: あなたのプライバシーが最優先\n\n> *次世代モバイルアプリケーションを体験してください。*',
            author: 'localization-specialist@company.com',
            timestamp: DateTime.now().subtract(const Duration(hours: 6)),
            status: TranslationStatus.review,
            version: '1.0.0',
            tags: ['features', 'description'],
          ),
        },
      ),
    };
  }

  String _stripHtml(String html) {
    return html.replaceAll(RegExp(r'<[^>]*>'), '').replaceAll('&nbsp;', ' ');
  }

  String _convertToMarkdown(String content) {
    // This is a simplified conversion - in production, use a proper converter
    return content;
  }

  String _formatAsJson(String content) {
    return jsonEncode({'content': content, 'locale': locale.toString()});
  }
}

class ContentManagerDelegate extends LocalizationsDelegate<ContentManager> {
  const ContentManagerDelegate();

  @override
  bool isSupported(Locale locale) => true;

  @override
  Future<ContentManager> load(Locale locale) async {
    return ContentManager(locale);
  }

  @override
  bool shouldReload(ContentManagerDelegate old) => false;
}

class ContentManagementExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const ContentManagementExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<ContentManagementExample> createState() => _ContentManagementExampleState();
}

class _ContentManagementExampleState extends State<ContentManagementExample> {
  String _selectedContentKey = 'app_welcome';
  ContentType _selectedContentType = ContentType.html;

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
    Locale('ja'): '🇯🇵 Japanese',
    Locale('ar'): '🇸🇦 Arabic',
  };

  @override
  Widget build(BuildContext context) {
    final contentManager = ContentManager.of(context)!;
    final currentLocale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Content Management'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildContentSelector(contentManager),
            const SizedBox(height: 20),
            _buildContentPreview(contentManager),
            const SizedBox(height: 20),
            _buildVersionInfo(contentManager, currentLocale),
            const SizedBox(height: 20),
            _buildTranslationStatus(contentManager),
            const SizedBox(height: 20),
            _buildWorkflowManagement(contentManager),
          ],
        ),
      ),
    );
  }

  Widget _buildContentSelector(ContentManager contentManager) {
    final contentKeys = ['app_welcome', 'feature_description'];
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Content Selection',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _selectedContentKey,
              decoration: const InputDecoration(
                labelText: 'Content Item',
                border: OutlineInputBorder(),
              ),
              items: contentKeys.map((key) {
                return DropdownMenuItem<String>(
                  value: key,
                  child: Text(key.replaceAll('_', ' ').toUpperCase()),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() => _selectedContentKey = value);
                }
              },
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<ContentType>(
              value: _selectedContentType,
              decoration: const InputDecoration(
                labelText: 'Content Format',
                border: OutlineInputBorder(),
              ),
              items: ContentType.values.map((type) {
                return DropdownMenuItem<ContentType>(
                  value: type,
                  child: Text(type.name.toUpperCase()),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() => _selectedContentType = value);
                }
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContentPreview(ContentManager contentManager) {
    final content = contentManager.getContent(_selectedContentKey, type: _selectedContentType);
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Text(
                  'Content Preview',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                Chip(
                  label: Text(_selectedContentType.name.toUpperCase()),
                  backgroundColor: Colors.blue[100],
                ),
              ],
            ),
            const SizedBox(height: 16),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16.0),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey[300]!),
                borderRadius: BorderRadius.circular(8),
                color: Colors.grey[50],
              ),
              child: _selectedContentType == ContentType.html
                  ? _buildHtmlPreview(content)
                  : Text(
                      content,
                      style: _selectedContentType == ContentType.json
                          ? const TextStyle(fontFamily: 'monospace', fontSize: 12)
                          : null,
                    ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHtmlPreview(String htmlContent) {
    // Simplified HTML rendering - in production, use flutter_html package
    final cleanContent = htmlContent
        .replaceAll(RegExp(r'<h[1-6]>'), '')
        .replaceAll(RegExp(r'</h[1-6]>'), '\n')
        .replaceAll('<p>', '')
        .replaceAll('</p>', '\n')
        .replaceAll('<strong>', '')
        .replaceAll('</strong>', '')
        .replaceAll(RegExp(r'<[^>]*>'), '');
        
    return Text(
      cleanContent,
      style: const TextStyle(fontSize: 16),
    );
  }

  Widget _buildVersionInfo(ContentManager contentManager, Locale locale) {
    final entry = contentManager.getContentEntry(_selectedContentKey);
    if (entry == null) return const SizedBox();

    final availableLanguages = contentManager.getAvailableLanguages(_selectedContentKey);
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Version Information',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildInfoRow('Content Key', entry.key),
            _buildInfoRow('Content Type', entry.type.name),
            _buildInfoRow('Created', _formatDate(entry.created)),
            _buildInfoRow('Last Modified', _formatDate(entry.lastModified)),
            _buildInfoRow('Available Languages', availableLanguages.join(', ')),
            _buildInfoRow('Current Locale', locale.toString()),
            const SizedBox(height: 16),
            const Text(
              'Language Versions:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            ...entry.versions.entries.map((version) => 
                _buildVersionRow(version.key, version.value)),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 140,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(child: Text(value)),
        ],
      ),
    );
  }

  Widget _buildVersionRow(String languageCode, ContentVersion version) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 60,
            child: Text(
              languageCode.toUpperCase(),
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Text('v${version.version}'),
                    const SizedBox(width: 8),
                    _buildStatusChip(version.status),
                  ],
                ),
                Text(
                  'by ${version.author} • ${_formatDate(version.timestamp)}',
                  style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusChip(TranslationStatus status) {
    final colors = {
      TranslationStatus.draft: Colors.orange,
      TranslationStatus.review: Colors.blue,
      TranslationStatus.approved: Colors.green,
      TranslationStatus.published: Colors.purple,
      TranslationStatus.outdated: Colors.red,
    };

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: colors[status]!.withOpacity(0.2),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        status.name.toUpperCase(),
        style: TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: colors[status],
        ),
      ),
    );
  }

  Widget _buildTranslationStatus(ContentManager contentManager) {
    final status = contentManager.getTranslationStatus(_selectedContentKey);
    final availableLanguages = contentManager.getAvailableLanguages(_selectedContentKey);
    final supportedLocales = ['en', 'es', 'fr', 'de', 'ja', 'ar'];
    final missingLanguages = supportedLocales.where((lang) => !availableLanguages.contains(lang)).toList();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Translation Status',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                const Text('Current Status: '),
                _buildStatusChip(status),
              ],
            ),
            const SizedBox(height: 16),
            Text('Translation Coverage: ${availableLanguages.length}/${supportedLocales.length} languages'),
            const SizedBox(height: 8),
            LinearProgressIndicator(
              value: availableLanguages.length / supportedLocales.length,
              backgroundColor: Colors.grey[300],
              valueColor: AlwaysStoppedAnimation<Color>(
                availableLanguages.length == supportedLocales.length 
                    ? Colors.green 
                    : Colors.orange,
              ),
            ),
            if (missingLanguages.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(
                'Missing Languages: ${missingLanguages.join(', ')}',
                style: TextStyle(color: Colors.red[700]),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildWorkflowManagement(ContentManager contentManager) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Workflow Management',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            const Text('Content Workflow Actions:'),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _buildActionChip('Request Translation', Icons.translate, Colors.blue),
                _buildActionChip('Submit for Review', Icons.rate_review, Colors.orange),
                _buildActionChip('Approve Content', Icons.check_circle, Colors.green),
                _buildActionChip('Publish', Icons.publish, Colors.purple),
                _buildActionChip('Archive', Icons.archive, Colors.grey),
              ],
            ),
            const SizedBox(height: 16),
            const Text('Quality Assurance:'),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _buildActionChip('Spell Check', Icons.spellcheck, Colors.indigo),
                _buildActionChip('Grammar Check', Icons.text_fields, Colors.teal),
                _buildActionChip('Cultural Review', Icons.public, Colors.deepOrange),
                _buildActionChip('A/B Test', Icons.science, Colors.cyan),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionChip(String label, IconData icon, Color color) {
    return ActionChip(
      avatar: Icon(icon, size: 18, color: color),
      label: Text(label),
      onPressed: () {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('$label action triggered')),
        );
      },
    );
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}
```

Multi-language content management systems track translations across  
different languages, versions, and approval workflows. This approach  
enables professional localization teams to manage content lifecycle,  
quality assurance, and deployment processes. Version control and status  
tracking ensure consistency and quality across all supported languages.

## Accessibility and Internationalization

Combining accessibility features with internationalization to create  
inclusive experiences for users with disabilities across different  
languages and cultures.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Accessibility & I18n',
      locale: _currentLocale,
      localizationsDelegates: const [
        AccessibleLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('es', 'ES'),
        Locale('fr', 'FR'),
        Locale('ja', 'JP'),
        Locale('ar', 'SA'),
        Locale('de', 'DE'),
      ],
      home: AccessibilityI18nExample(onLocaleChange: _changeLocale),
    );
  }
}

class AccessibleLocalizations {
  final Locale locale;

  AccessibleLocalizations(this.locale);

  static AccessibleLocalizations? of(BuildContext context) {
    return Localizations.of<AccessibleLocalizations>(
        context, AccessibleLocalizations);
  }

  static final Map<String, Map<String, dynamic>> _translations = {
    'en': {
      'screen_reader_welcome': 'Welcome to the accessible application',
      'button_press_hint': 'Double tap to activate',
      'navigation_hint': 'Swipe right to navigate forward',
      'volume_control': 'Volume control',
      'increase_volume': 'Increase volume',
      'decrease_volume': 'Decrease volume',
      'current_volume': 'Current volume level',
      'language_selector': 'Language selector',
      'font_size_control': 'Font size control',
      'increase_font': 'Increase font size',
      'decrease_font': 'Decrease font size',
      'high_contrast': 'High contrast mode',
      'reading_order': 'Reading order adjustment',
      'announcement_new_content': 'New content loaded',
      'error_announcement': 'Error occurred, please try again',
      'success_announcement': 'Action completed successfully',
      'loading_announcement': 'Loading content, please wait',
      'semantic_labels': {
        'home': 'Home navigation',
        'settings': 'Application settings',
        'profile': 'User profile',
        'search': 'Search functionality',
        'menu': 'Main navigation menu',
      }
    },
    'es': {
      'screen_reader_welcome': 'Bienvenido a la aplicación accesible',
      'button_press_hint': 'Toque dos veces para activar',
      'navigation_hint': 'Desliza hacia la derecha para navegar hacia adelante',
      'volume_control': 'Control de volumen',
      'increase_volume': 'Aumentar volumen',
      'decrease_volume': 'Disminuir volumen',
      'current_volume': 'Nivel de volumen actual',
      'language_selector': 'Selector de idioma',
      'font_size_control': 'Control de tamaño de fuente',
      'increase_font': 'Aumentar tamaño de fuente',
      'decrease_font': 'Disminuir tamaño de fuente',
      'high_contrast': 'Modo de alto contraste',
      'reading_order': 'Ajuste del orden de lectura',
      'announcement_new_content': 'Nuevo contenido cargado',
      'error_announcement': 'Error ocurrido, por favor intente de nuevo',
      'success_announcement': 'Acción completada exitosamente',
      'loading_announcement': 'Cargando contenido, por favor espere',
      'semantic_labels': {
        'home': 'Navegación de inicio',
        'settings': 'Configuraciones de la aplicación',
        'profile': 'Perfil de usuario',
        'search': 'Funcionalidad de búsqueda',
        'menu': 'Menú de navegación principal',
      }
    },
    'ja': {
      'screen_reader_welcome': 'アクセシブルアプリケーションへようこそ',
      'button_press_hint': 'ダブルタップして有効化',
      'navigation_hint': '右にスワイプして前進',
      'volume_control': 'ボリュームコントロール',
      'increase_volume': 'ボリュームを上げる',
      'decrease_volume': 'ボリュームを下げる',
      'current_volume': '現在のボリュームレベル',
      'language_selector': '言語セレクター',
      'font_size_control': 'フォントサイズコントロール',
      'increase_font': 'フォントサイズを大きく',
      'decrease_font': 'フォントサイズを小さく',
      'high_contrast': 'ハイコントラストモード',
      'reading_order': '読み順の調整',
      'announcement_new_content': '新しいコンテンツが読み込まれました',
      'error_announcement': 'エラーが発生しました。もう一度お試しください',
      'success_announcement': 'アクションが正常に完了しました',
      'loading_announcement': 'コンテンツを読み込み中です。お待ちください',
      'semantic_labels': {
        'home': 'ホームナビゲーション',
        'settings': 'アプリケーション設定',
        'profile': 'ユーザープロフィール',
        'search': '検索機能',
        'menu': 'メインナビゲーションメニュー',
      }
    },
  };

  String translate(String key) {
    final langMap = _translations[locale.languageCode] ?? _translations['en']!;
    if (langMap[key] is String) {
      return langMap[key] as String;
    }
    return langMap[key]?.toString() ?? key;
  }

  String getSemanticLabel(String key) {
    final langMap = _translations[locale.languageCode] ?? _translations['en']!;
    final labels = langMap['semantic_labels'] as Map<String, dynamic>? ?? {};
    return labels[key]?.toString() ?? key;
  }
}

class AccessibleLocalizationsDelegate
    extends LocalizationsDelegate<AccessibleLocalizations> {
  const AccessibleLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'es', 'fr', 'ja', 'ar', 'de'].contains(locale.languageCode);
  }

  @override
  Future<AccessibleLocalizations> load(Locale locale) async {
    return AccessibleLocalizations(locale);
  }

  @override
  bool shouldReload(AccessibleLocalizationsDelegate old) => false;
}

class AccessibilityI18nExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const AccessibilityI18nExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<AccessibilityI18nExample> createState() =>
      _AccessibilityI18nExampleState();
}

class _AccessibilityI18nExampleState extends State<AccessibilityI18nExample> {
  double _volume = 50;
  double _fontSize = 16;
  bool _highContrast = false;
  int _selectedIndex = 0;

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 English',
    Locale('es', 'ES'): '🇪🇸 Español',
    Locale('fr', 'FR'): '🇫🇷 Français',
    Locale('ja', 'JP'): '🇯🇵 日本語',
    Locale('ar', 'SA'): '🇸🇦 العربية',
    Locale('de', 'DE'): '🇩🇪 Deutsch',
  };

  @override
  Widget build(BuildContext context) {
    final localizations = AccessibleLocalizations.of(context)!;
    final isRTL = Directionality.of(context) == TextDirection.rtl;

    return Scaffold(
      appBar: AppBar(
        title: Semantics(
          label: localizations.getSemanticLabel('home'),
          child: const Text('Accessibility & I18n'),
        ),
        actions: [
          Semantics(
            label: localizations.translate('language_selector'),
            button: true,
            child: PopupMenuButton<Locale>(
              icon: const Icon(Icons.language),
              onSelected: (locale) {
                widget.onLocaleChange(locale);
                _announceLanguageChange(localizations, locale);
              },
              itemBuilder: (context) {
                return _localeNames.entries.map((entry) {
                  return PopupMenuItem<Locale>(
                    value: entry.key,
                    child: Semantics(
                      button: true,
                      child: Text(entry.value),
                    ),
                  );
                }).toList();
              },
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildWelcomeSection(localizations),
            const SizedBox(height: 20),
            _buildVolumeControl(localizations),
            const SizedBox(height: 20),
            _buildFontSizeControl(localizations),
            const SizedBox(height: 20),
            _buildAccessibilitySettings(localizations),
            const SizedBox(height: 20),
            _buildNavigationExample(localizations, isRTL),
            const SizedBox(height: 20),
            _buildAnnouncementDemo(localizations),
          ],
        ),
      ),
      bottomNavigationBar: _buildAccessibleBottomNav(localizations),
    );
  }

  Widget _buildWelcomeSection(AccessibleLocalizations localizations) {
    return Semantics(
      label: localizations.translate('screen_reader_welcome'),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                localizations.translate('screen_reader_welcome'),
                style: TextStyle(
                  fontSize: _fontSize + 4,
                  fontWeight: FontWeight.bold,
                  color: _highContrast ? Colors.black : null,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'This example demonstrates accessible internationalization patterns.',
                style: TextStyle(
                  fontSize: _fontSize,
                  color: _highContrast ? Colors.black87 : null,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildVolumeControl(AccessibleLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('volume_control'),
              style: TextStyle(
                fontSize: _fontSize + 2,
                fontWeight: FontWeight.bold,
                color: _highContrast ? Colors.black : null,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Semantics(
                  label: localizations.translate('decrease_volume'),
                  button: true,
                  onTapHint: localizations.translate('button_press_hint'),
                  child: IconButton(
                    icon: const Icon(Icons.volume_down),
                    onPressed: () {
                      setState(() {
                        _volume = (_volume - 10).clamp(0, 100);
                      });
                      _announceVolumeChange(localizations);
                    },
                  ),
                ),
                Expanded(
                  child: Semantics(
                    label: '${localizations.translate('current_volume')}: ${_volume.round()}%',
                    slider: true,
                    value: _volume,
                    child: Slider(
                      value: _volume,
                      min: 0,
                      max: 100,
                      divisions: 10,
                      onChanged: (value) {
                        setState(() {
                          _volume = value;
                        });
                      },
                      onChangeEnd: (value) {
                        _announceVolumeChange(localizations);
                      },
                    ),
                  ),
                ),
                Semantics(
                  label: localizations.translate('increase_volume'),
                  button: true,
                  onTapHint: localizations.translate('button_press_hint'),
                  child: IconButton(
                    icon: const Icon(Icons.volume_up),
                    onPressed: () {
                      setState(() {
                        _volume = (_volume + 10).clamp(0, 100);
                      });
                      _announceVolumeChange(localizations);
                    },
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFontSizeControl(AccessibleLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('font_size_control'),
              style: TextStyle(
                fontSize: _fontSize + 2,
                fontWeight: FontWeight.bold,
                color: _highContrast ? Colors.black : null,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Semantics(
                  label: localizations.translate('decrease_font'),
                  button: true,
                  child: IconButton(
                    icon: const Icon(Icons.text_decrease),
                    onPressed: _fontSize > 12 ? () {
                      setState(() {
                        _fontSize = (_fontSize - 2).clamp(12, 24);
                      });
                    } : null,
                  ),
                ),
                Expanded(
                  child: Text(
                    'Sample text at ${_fontSize.round()}px',
                    style: TextStyle(
                      fontSize: _fontSize,
                      color: _highContrast ? Colors.black : null,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
                Semantics(
                  label: localizations.translate('increase_font'),
                  button: true,
                  child: IconButton(
                    icon: const Icon(Icons.text_increase),
                    onPressed: _fontSize < 24 ? () {
                      setState(() {
                        _fontSize = (_fontSize + 2).clamp(12, 24);
                      });
                    } : null,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAccessibilitySettings(AccessibleLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Accessibility Settings',
              style: TextStyle(
                fontSize: _fontSize + 2,
                fontWeight: FontWeight.bold,
                color: _highContrast ? Colors.black : null,
              ),
            ),
            const SizedBox(height: 16),
            Semantics(
              toggled: _highContrast,
              label: localizations.translate('high_contrast'),
              child: SwitchListTile(
                title: Text(
                  localizations.translate('high_contrast'),
                  style: TextStyle(
                    fontSize: _fontSize,
                    color: _highContrast ? Colors.black : null,
                  ),
                ),
                value: _highContrast,
                onChanged: (value) {
                  setState(() {
                    _highContrast = value;
                  });
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavigationExample(AccessibleLocalizations localizations, bool isRTL) {
    final items = [
      {'icon': Icons.home, 'key': 'home'},
      {'icon': Icons.search, 'key': 'search'},
      {'icon': Icons.person, 'key': 'profile'},
      {'icon': Icons.settings, 'key': 'settings'},
    ];

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Accessible Navigation',
              style: TextStyle(
                fontSize: _fontSize + 2,
                fontWeight: FontWeight.bold,
                color: _highContrast ? Colors.black : null,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: items.map((item) {
                final index = items.indexOf(item);
                final isSelected = index == _selectedIndex;
                
                return Semantics(
                  label: localizations.getSemanticLabel(item['key'] as String),
                  button: true,
                  selected: isSelected,
                  onTapHint: localizations.translate('button_press_hint'),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () {
                        setState(() {
                          _selectedIndex = index;
                        });
                        _announceSelection(localizations, item['key'] as String);
                      },
                      borderRadius: BorderRadius.circular(12),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(12),
                          color: isSelected 
                              ? Theme.of(context).primaryColor.withOpacity(0.2)
                              : null,
                        ),
                        child: Icon(
                          item['icon'] as IconData,
                          color: isSelected 
                              ? Theme.of(context).primaryColor
                              : _highContrast ? Colors.black : null,
                        ),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAnnouncementDemo(AccessibleLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Screen Reader Announcements',
              style: TextStyle(
                fontSize: _fontSize + 2,
                fontWeight: FontWeight.bold,
                color: _highContrast ? Colors.black : null,
              ),
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _buildAnnouncementButton(
                  'Loading',
                  () => _makeAnnouncement(localizations.translate('loading_announcement')),
                ),
                _buildAnnouncementButton(
                  'Success',
                  () => _makeAnnouncement(localizations.translate('success_announcement')),
                ),
                _buildAnnouncementButton(
                  'Error',
                  () => _makeAnnouncement(localizations.translate('error_announcement')),
                ),
                _buildAnnouncementButton(
                  'New Content',
                  () => _makeAnnouncement(localizations.translate('announcement_new_content')),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAnnouncementButton(String label, VoidCallback onPressed) {
    return ElevatedButton(
      onPressed: onPressed,
      child: Text(
        label,
        style: TextStyle(
          fontSize: _fontSize - 2,
          color: _highContrast ? Colors.black : null,
        ),
      ),
    );
  }

  Widget _buildAccessibleBottomNav(AccessibleLocalizations localizations) {
    return Semantics(
      label: localizations.getSemanticLabel('menu'),
      container: true,
      child: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: [
          BottomNavigationBarItem(
            icon: Semantics(
              label: localizations.getSemanticLabel('home'),
              excludeSemantics: true,
              child: const Icon(Icons.home),
            ),
            label: localizations.getSemanticLabel('home'),
          ),
          BottomNavigationBarItem(
            icon: Semantics(
              label: localizations.getSemanticLabel('search'),
              excludeSemantics: true,
              child: const Icon(Icons.search),
            ),
            label: localizations.getSemanticLabel('search'),
          ),
          BottomNavigationBarItem(
            icon: Semantics(
              label: localizations.getSemanticLabel('profile'),
              excludeSemantics: true,
              child: const Icon(Icons.person),
            ),
            label: localizations.getSemanticLabel('profile'),
          ),
          BottomNavigationBarItem(
            icon: Semantics(
              label: localizations.getSemanticLabel('settings'),
              excludeSemantics: true,
              child: const Icon(Icons.settings),
            ),
            label: localizations.getSemanticLabel('settings'),
          ),
        ],
      ),
    );
  }

  void _announceVolumeChange(AccessibleLocalizations localizations) {
    _makeAnnouncement(
      '${localizations.translate('current_volume')}: ${_volume.round()}%',
    );
  }

  void _announceLanguageChange(AccessibleLocalizations localizations, Locale locale) {
    _makeAnnouncement(
      'Language changed to ${_localeNames[locale] ?? locale.toString()}',
    );
  }

  void _announceSelection(AccessibleLocalizations localizations, String key) {
    _makeAnnouncement(
      '${localizations.getSemanticLabel(key)} selected',
    );
  }

  void _makeAnnouncement(String message) {
    SemanticsService.announce(message, TextDirection.ltr);
  }
}
```

Accessibility and internationalization work together to create truly  
inclusive applications. Screen readers need localized announcements,  
semantic labels must be translated, and accessibility features should  
adapt to different cultural contexts. This example demonstrates proper  
semantic markup, localized screen reader announcements, and culturally  
appropriate accessibility patterns for global applications.

## Locale-Sensitive Sorting

Implementing culturally appropriate sorting algorithms that respect  
language-specific collation rules and character ordering.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Locale-Sensitive Sorting',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('de'),
        Locale('fr'),
        Locale('es'),
        Locale('sv'),
        Locale('ja'),
        Locale('zh'),
        Locale('ar'),
      ],
      home: LocaleSortingExample(onLocaleChange: _changeLocale),
    );
  }
}

class LocaleSortingExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const LocaleSortingExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<LocaleSortingExample> createState() => _LocaleSortingExampleState();
}

class _LocaleSortingExampleState extends State<LocaleSortingExample> {
  List<String> _names = [];
  List<String> _sortedNames = [];
  String _sortMethod = 'locale_aware';

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('de'): '🇩🇪 German',
    Locale('fr'): '🇫🇷 French',
    Locale('es'): '🇪🇸 Spanish',
    Locale('sv'): '🇸🇪 Swedish',
    Locale('ja'): '🇯🇵 Japanese',
    Locale('zh'): '🇨🇳 Chinese',
    Locale('ar'): '🇸🇦 Arabic',
  };

  // Sample names with special characters for testing
  static const Map<String, List<String>> _sampleData = {
    'en': ['Smith', 'Anderson', 'O\'Connor', 'MacLeod', 'Żółć', 'Ångström'],
    'de': ['Müller', 'Schmidt', 'Schneider', 'Fischer', 'Weber', 'Äöüß'],
    'fr': ['Martin', 'Bernard', 'Dubois', 'Thomas', 'Robert', 'Café', 'Naïve'],
    'es': ['García', 'González', 'López', 'Martínez', 'Sánchez', 'Ñoño'],
    'sv': ['Andersson', 'Johansson', 'Karlsson', 'Nilsson', 'Åberg', 'Öberg'],
    'ja': ['田中', '山田', '佐藤', '中村', '小林', 'アベ', 'カトウ'],
    'zh': ['王', '李', '张', '刘', '陈', '杨', '黄'],
    'ar': ['أحمد', 'محمد', 'علي', 'حسن', 'فاطمة', 'عائشة'],
  };

  @override
  void initState() {
    super.initState();
    _updateSampleData();
  }

  @override
  void didUpdateWidget(LocaleSortingExample oldWidget) {
    super.didUpdateWidget(oldWidget);
    _updateSampleData();
  }

  void _updateSampleData() {
    final locale = Localizations.localeOf(context);
    _names = List.from(_sampleData[locale.languageCode] ?? _sampleData['en']!);
    _sortNames();
  }

  void _sortNames() {
    final locale = Localizations.localeOf(context);
    
    setState(() {
      switch (_sortMethod) {
        case 'locale_aware':
          _sortedNames = _localizedSort(_names, locale);
          break;
        case 'case_sensitive':
          _sortedNames = List.from(_names)..sort();
          break;
        case 'case_insensitive':
          _sortedNames = List.from(_names)
            ..sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));
          break;
        case 'unicode':
          _sortedNames = List.from(_names)
            ..sort((a, b) => a.codeUnits.join().compareTo(b.codeUnits.join()));
          break;
      }
    });
  }

  List<String> _localizedSort(List<String> items, Locale locale) {
    try {
      final collator = Collator(locale.toString());
      return List.from(items)..sort(collator.compare);
    } catch (e) {
      // Fallback to basic sorting if Collator is not available
      return List.from(items)..sort();
    }
  }

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Locale-Sensitive Sorting'),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildLocaleInfo(locale),
            const SizedBox(height: 20),
            _buildSortMethodSelector(),
            const SizedBox(height: 20),
            _buildComparisonView(),
          ],
        ),
      ),
    );
  }

  Widget _buildLocaleInfo(Locale locale) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Current Locale',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text('Language: ${locale.languageCode}'),
            Text('Locale: ${locale.toString()}'),
            Text('Sample: ${_localeNames[locale] ?? "Unknown"}'),
          ],
        ),
      ),
    );
  }

  Widget _buildSortMethodSelector() {
    final methods = {
      'locale_aware': 'Locale-Aware (Collator)',
      'case_sensitive': 'Case-Sensitive ASCII',
      'case_insensitive': 'Case-Insensitive ASCII',
      'unicode': 'Unicode Code Points',
    };

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Sorting Method',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _sortMethod,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
              ),
              items: methods.entries.map((entry) {
                return DropdownMenuItem<String>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _sortMethod = value;
                  });
                  _sortNames();
                }
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildComparisonView() {
    return Expanded(
      child: Row(
        children: [
          Expanded(
            child: Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Original Order',
                      style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    Expanded(
                      child: ListView.builder(
                        itemCount: _names.length,
                        itemBuilder: (context, index) {
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 4.0),
                            child: Row(
                              children: [
                                Container(
                                  width: 24,
                                  height: 24,
                                  decoration: BoxDecoration(
                                    color: Colors.grey[300],
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Center(
                                    child: Text(
                                      '${index + 1}',
                                      style: const TextStyle(fontSize: 12),
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Text(
                                  _names[index],
                                  style: const TextStyle(fontSize: 16),
                                ),
                              ],
                            ),
                          );
                        },
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Sorted (${_getSortMethodName()})',
                      style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    Expanded(
                      child: ListView.builder(
                        itemCount: _sortedNames.length,
                        itemBuilder: (context, index) {
                          final originalIndex = _names.indexOf(_sortedNames[index]);
                          final moved = originalIndex != index;
                          
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 4.0),
                            child: Row(
                              children: [
                                Container(
                                  width: 24,
                                  height: 24,
                                  decoration: BoxDecoration(
                                    color: moved ? Colors.blue[200] : Colors.grey[300],
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Center(
                                    child: Text(
                                      '${index + 1}',
                                      style: TextStyle(
                                        fontSize: 12,
                                        fontWeight: moved ? FontWeight.bold : FontWeight.normal,
                                      ),
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Text(
                                  _sortedNames[index],
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: moved ? FontWeight.w600 : FontWeight.normal,
                                  ),
                                ),
                                if (moved) ...[
                                  const Spacer(),
                                  Icon(
                                    Icons.swap_vert,
                                    size: 16,
                                    color: Colors.blue[600],
                                  ),
                                ],
                              ],
                            ),
                          );
                        },
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getSortMethodName() {
    switch (_sortMethod) {
      case 'locale_aware':
        return 'Locale-Aware';
      case 'case_sensitive':
        return 'Case-Sensitive';
      case 'case_insensitive':
        return 'Case-Insensitive';
      case 'unicode':
        return 'Unicode';
      default:
        return 'Unknown';
    }
  }
}
```

Locale-sensitive sorting ensures that names and text appear in the  
expected order for different languages. German sorts 'ä' after 'a',  
Swedish places 'å' at the end, and many languages have unique collation  
rules. The Collator class provides culturally appropriate sorting that  
respects local conventions and user expectations.

## Performance Optimization for I18n

Optimizing internationalization performance through lazy loading,  
caching strategies, and efficient translation management.  

```dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'I18n Performance',
      locale: _currentLocale,
      localizationsDelegates: const [
        PerformantLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
        Locale('ja'),
      ],
      home: PerformanceOptimizationExample(onLocaleChange: _changeLocale),
    );
  }
}

class PerformantLocalizations {
  final Locale locale;
  
  // Cache for loaded translations
  static final Map<String, Map<String, String>> _cache = {};
  
  // Loading states
  static final Map<String, bool> _loadingStates = {};
  
  // Performance metrics
  static final Map<String, PerformanceMetrics> _metrics = {};

  PerformantLocalizations._(this.locale);

  static PerformantLocalizations? of(BuildContext context) {
    return Localizations.of<PerformantLocalizations>(
        context, PerformantLocalizations);
  }

  static Future<PerformantLocalizations> load(Locale locale) async {
    final instance = PerformantLocalizations._(locale);
    await instance._loadTranslations();
    return instance;
  }

  Future<void> _loadTranslations() async {
    final localeKey = locale.toString();
    
    if (_cache.containsKey(localeKey)) {
      _updateMetrics(localeKey, fromCache: true);
      return;
    }

    if (_loadingStates[localeKey] == true) {
      // Wait for existing load to complete
      while (_loadingStates[localeKey] == true) {
        await Future.delayed(const Duration(milliseconds: 10));
      }
      return;
    }

    _loadingStates[localeKey] = true;
    
    try {
      final stopwatch = Stopwatch()..start();
      
      // Simulate loading from different sources
      final translations = await _fetchTranslations(locale);
      
      stopwatch.stop();
      
      _cache[localeKey] = translations;
      _updateMetrics(localeKey, 
          loadTime: stopwatch.elapsedMilliseconds, 
          fromCache: false);
          
    } finally {
      _loadingStates[localeKey] = false;
    }
  }

  Future<Map<String, String>> _fetchTranslations(Locale locale) async {
    // Simulate network delay and processing time
    await Future.delayed(Duration(milliseconds: 50 + (locale.languageCode.length * 10)));
    
    // Return translations based on locale
    return _getStaticTranslations(locale.languageCode);
  }

  Map<String, String> _getStaticTranslations(String languageCode) {
    const translations = {
      'en': {
        'performance_title': 'I18n Performance Optimization',
        'cache_status': 'Cache Status',
        'load_time': 'Load Time',
        'memory_usage': 'Memory Usage',
        'translations_loaded': 'Translations Loaded',
        'cache_hit_rate': 'Cache Hit Rate',
        'lazy_loading': 'Lazy Loading Demo',
        'preloading': 'Preloading Demo',
        'clear_cache': 'Clear Cache',
        'reload_translations': 'Reload Translations',
        'performance_metrics': 'Performance Metrics',
      },
      'es': {
        'performance_title': 'Optimización de Rendimiento I18n',
        'cache_status': 'Estado de Caché',
        'load_time': 'Tiempo de Carga',
        'memory_usage': 'Uso de Memoria',
        'translations_loaded': 'Traducciones Cargadas',
        'cache_hit_rate': 'Tasa de Acierto de Caché',
        'lazy_loading': 'Demo de Carga Diferida',
        'preloading': 'Demo de Precarga',
        'clear_cache': 'Limpiar Caché',
        'reload_translations': 'Recargar Traducciones',
        'performance_metrics': 'Métricas de Rendimiento',
      },
    };
    
    return Map<String, String>.from(
        translations[languageCode] ?? translations['en']!);
  }

  void _updateMetrics(String localeKey, 
      {int? loadTime, bool fromCache = false}) {
    if (!_metrics.containsKey(localeKey)) {
      _metrics[localeKey] = PerformanceMetrics();
    }
    
    final metrics = _metrics[localeKey]!;
    
    if (fromCache) {
      metrics.cacheHits++;
    } else {
      metrics.cacheMisses++;
      if (loadTime != null) {
        metrics.totalLoadTime += loadTime;
        metrics.loadCount++;
      }
    }
  }

  String translate(String key) {
    final localeKey = locale.toString();
    return _cache[localeKey]?[key] ?? key;
  }

  static PerformanceMetrics getMetrics(String localeKey) {
    return _metrics[localeKey] ?? PerformanceMetrics();
  }

  static void clearCache() {
    _cache.clear();
    _metrics.clear();
    _loadingStates.clear();
  }

  static Map<String, String> getCacheStatus() {
    return Map.fromEntries(
        _cache.entries.map((e) => MapEntry(e.key, '${e.value.length} keys')));
  }
}

class PerformanceMetrics {
  int cacheHits = 0;
  int cacheMisses = 0;
  int totalLoadTime = 0;
  int loadCount = 0;

  double get cacheHitRate => 
      (cacheHits + cacheMisses) > 0 
          ? cacheHits / (cacheHits + cacheMisses) 
          : 0.0;

  double get averageLoadTime => 
      loadCount > 0 ? totalLoadTime / loadCount : 0.0;
}

class PerformantLocalizationsDelegate
    extends LocalizationsDelegate<PerformantLocalizations> {
  const PerformantLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) => true;

  @override
  Future<PerformantLocalizations> load(Locale locale) {
    return PerformantLocalizations.load(locale);
  }

  @override
  bool shouldReload(PerformantLocalizationsDelegate old) => false;
}

class PerformanceOptimizationExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const PerformanceOptimizationExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<PerformanceOptimizationExample> createState() =>
      _PerformanceOptimizationExampleState();
}

class _PerformanceOptimizationExampleState
    extends State<PerformanceOptimizationExample> {
  Timer? _metricsTimer;
  
  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
    Locale('ja'): '🇯🇵 Japanese',
  };

  @override
  void initState() {
    super.initState();
    _startMetricsTimer();
  }

  @override
  void dispose() {
    _metricsTimer?.cancel();
    super.dispose();
  }

  void _startMetricsTimer() {
    _metricsTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (mounted) setState(() {});
    });
  }

  @override
  Widget build(BuildContext context) {
    final localizations = PerformantLocalizations.of(context)!;
    final locale = Localizations.localeOf(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('performance_title')),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildCacheStatus(localizations),
            const SizedBox(height: 20),
            _buildPerformanceMetrics(localizations, locale),
            const SizedBox(height: 20),
            _buildOptimizationDemo(localizations),
            const SizedBox(height: 20),
            _buildControlButtons(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildCacheStatus(PerformantLocalizations localizations) {
    final cacheStatus = PerformantLocalizations.getCacheStatus();
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('cache_status'),
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            if (cacheStatus.isEmpty)
              const Text('No cached translations')
            else
              ...cacheStatus.entries.map((entry) => Padding(
                padding: const EdgeInsets.symmetric(vertical: 2.0),
                child: Row(
                  children: [
                    SizedBox(
                      width: 80,
                      child: Text(
                        '${entry.key}:',
                        style: const TextStyle(fontWeight: FontWeight.w500),
                      ),
                    ),
                    Text(entry.value),
                  ],
                ),
              )),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceMetrics(
      PerformantLocalizations localizations, Locale locale) {
    final metrics = PerformantLocalizations.getMetrics(locale.toString());
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('performance_metrics'),
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildMetricRow('Cache Hits', '${metrics.cacheHits}'),
            _buildMetricRow('Cache Misses', '${metrics.cacheMisses}'),
            _buildMetricRow('Hit Rate', '${(metrics.cacheHitRate * 100).toStringAsFixed(1)}%'),
            _buildMetricRow('Avg Load Time', '${metrics.averageLoadTime.toStringAsFixed(1)}ms'),
            _buildMetricRow('Total Loads', '${metrics.loadCount}'),
            const SizedBox(height: 16),
            LinearProgressIndicator(
              value: metrics.cacheHitRate,
              backgroundColor: Colors.red[200],
              valueColor: AlwaysStoppedAnimation<Color>(Colors.green[400]!),
            ),
            const SizedBox(height: 4),
            Text(
              'Cache Efficiency: ${(metrics.cacheHitRate * 100).toStringAsFixed(1)}%',
              style: const TextStyle(fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMetricRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2.0),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Text(value),
        ],
      ),
    );
  }

  Widget _buildOptimizationDemo(PerformantLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Optimization Techniques',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildOptimizationTile(
              'Lazy Loading',
              'Translations loaded on-demand when locale changes',
              Icons.download,
              Colors.blue,
            ),
            _buildOptimizationTile(
              'Memory Cache',
              'Translations cached in memory to avoid reloading',
              Icons.memory,
              Colors.green,
            ),
            _buildOptimizationTile(
              'Async Loading',
              'Non-blocking translation loading with proper states',
              Icons.hourglass_empty,
              Colors.orange,
            ),
            _buildOptimizationTile(
              'Deduplication',
              'Multiple locale requests share the same loading process',
              Icons.merge,
              Colors.purple,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildOptimizationTile(
      String title, String description, IconData icon, Color color) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Container(
            width: 40,
            height: 40,
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(icon, color: color),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(fontWeight: FontWeight.w600),
                ),
                Text(
                  description,
                  style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildControlButtons(PerformantLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Cache Controls',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () {
                      PerformantLocalizations.clearCache();
                      setState(() {});
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('Cache cleared')),
                      );
                    },
                    child: Text(localizations.translate('clear_cache')),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () async {
                      // Force reload by clearing and changing locale
                      final currentLocale = Localizations.localeOf(context);
                      widget.onLocaleChange(const Locale('temp'));
                      await Future.delayed(const Duration(milliseconds: 100));
                      widget.onLocaleChange(currentLocale);
                      
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Translations reloaded')),
                        );
                      }
                    },
                    child: Text(localizations.translate('reload_translations')),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

Performance optimization in internationalization focuses on efficient  
loading and caching strategies. Lazy loading prevents unnecessary  
translation downloads, memory caching eliminates redundant requests,  
and async loading maintains UI responsiveness. These optimizations  
are crucial for apps supporting many languages or large translation  
sets while ensuring smooth user experiences.

## Testing Internationalization

Comprehensive testing strategies for internationalized applications,  
including unit tests, widget tests, and automated locale validation.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const TestableI18nApp());
}

class TestableI18nApp extends StatefulWidget {
  const TestableI18nApp({super.key});

  @override
  State<TestableI18nApp> createState() => _TestableI18nAppState();
}

class _TestableI18nAppState extends State<TestableI18nApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'I18n Testing',
      locale: _currentLocale,
      localizationsDelegates: const [
        TestableLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
        Locale('de'),
      ],
      home: I18nTestingExample(onLocaleChange: _changeLocale),
    );
  }
}

class TestableLocalizations {
  final Locale locale;

  TestableLocalizations(this.locale);

  static TestableLocalizations? of(BuildContext context) {
    return Localizations.of<TestableLocalizations>(
        context, TestableLocalizations);
  }

  static const Map<String, Map<String, String>> _translations = {
    'en': {
      'app_title': 'I18n Testing Suite',
      'test_results': 'Test Results',
      'translation_coverage': 'Translation Coverage',
      'missing_keys': 'Missing Translation Keys',
      'placeholder_detection': 'Placeholder Detection',
      'text_overflow': 'Text Overflow Issues',
      'run_tests': 'Run I18n Tests',
      'validation_passed': 'All validations passed',
      'validation_failed': 'Some validations failed',
      'key_missing_in': 'Key missing in {locale}',
      'placeholder_mismatch': 'Placeholder mismatch in {key}',
      'text_too_long': 'Text too long for UI in {locale}',
      'sample_long_text': 'This is a very long text that might cause UI overflow issues',
      'sample_with_placeholder': 'Hello {name}, you have {count} messages',
    },
    'es': {
      'app_title': 'Suite de Pruebas I18n',
      'test_results': 'Resultados de Prueba',
      'translation_coverage': 'Cobertura de Traducción',
      'missing_keys': 'Claves de Traducción Faltantes',
      'placeholder_detection': 'Detección de Marcadores',
      'text_overflow': 'Problemas de Desbordamiento de Texto',
      'run_tests': 'Ejecutar Pruebas I18n',
      'validation_passed': 'Todas las validaciones pasaron',
      'validation_failed': 'Algunas validaciones fallaron',
      'key_missing_in': 'Clave faltante en {locale}',
      'placeholder_mismatch': 'Desajuste de marcador en {key}',
      'text_too_long': 'Texto demasiado largo para UI en {locale}',
      'sample_long_text': 'Este es un texto muy largo que podría causar problemas de desbordamiento en la interfaz de usuario',
      'sample_with_placeholder': 'Hola {name}, tienes {count} mensajes',
    },
    'fr': {
      'app_title': 'Suite de Tests I18n',
      'test_results': 'Résultats de Test',
      'translation_coverage': 'Couverture de Traduction',
      'missing_keys': 'Clés de Traduction Manquantes',
      'placeholder_detection': 'Détection de Marqueurs',
      'text_overflow': 'Problèmes de Débordement de Texte',
      'run_tests': 'Exécuter Tests I18n',
      'validation_passed': 'Toutes les validations ont réussi',
      'validation_failed': 'Certaines validations ont échoué',
      'sample_long_text': 'Ceci est un texte très long qui pourrait causer des problèmes de débordement dans l\'interface utilisateur',
      // Intentionally missing some keys for testing
    },
    'de': {
      'app_title': 'I18n Test Suite',
      'test_results': 'Testergebnisse',
      'translation_coverage': 'Übersetzungsabdeckung',
      'missing_keys': 'Fehlende Übersetzungsschlüssel',
      'placeholder_detection': 'Platzhalter-Erkennung',
      'run_tests': 'I18n Tests Ausführen',
      'sample_with_placeholder': 'Hallo {name}, Sie haben {count} Nachrichten',
      // Intentionally missing many keys for testing
    },
  };

  String translate(String key, {Map<String, String>? parameters}) {
    var translation = _translations[locale.languageCode]?[key] ?? 
                     _translations['en']?[key] ?? 
                     key;

    if (parameters != null) {
      parameters.forEach((param, value) {
        translation = translation.replaceAll('{$param}', value);
      });
    }

    return translation;
  }

  // Testing utilities
  static List<String> getAllKeys() {
    final allKeys = <String>{};
    _translations.values.forEach((translations) {
      allKeys.addAll(translations.keys);
    });
    return allKeys.toList();
  }

  static Map<String, List<String>> getMissingKeys() {
    final allKeys = getAllKeys();
    final missing = <String, List<String>>{};

    for (final locale in _translations.keys) {
      final localeKeys = _translations[locale]!.keys.toSet();
      final missingInLocale = allKeys.where((key) => !localeKeys.contains(key)).toList();
      if (missingInLocale.isNotEmpty) {
        missing[locale] = missingInLocale;
      }
    }

    return missing;
  }

  static Map<String, Set<String>> getPlaceholderMismatches() {
    final mismatches = <String, Set<String>>{};
    final allKeys = getAllKeys();

    for (final key in allKeys) {
      final placeholders = <String, Set<String>>{};
      
      for (final locale in _translations.keys) {
        final translation = _translations[locale]?[key];
        if (translation != null) {
          final keyPlaceholders = _extractPlaceholders(translation);
          placeholders[locale] = keyPlaceholders;
        }
      }

      // Check for mismatches
      if (placeholders.values.isNotEmpty) {
        final basePlaceholders = placeholders.values.first;
        for (final entry in placeholders.entries) {
          if (!_setsEqual(basePlaceholders, entry.value)) {
            mismatches.putIfAbsent(key, () => <String>{}).add(entry.key);
          }
        }
      }
    }

    return mismatches;
  }

  static Set<String> _extractPlaceholders(String text) {
    final regex = RegExp(r'\{(\w+)\}');
    return regex.allMatches(text)
        .map((match) => match.group(1)!)
        .toSet();
  }

  static bool _setsEqual(Set<String> set1, Set<String> set2) {
    return set1.length == set2.length && set1.containsAll(set2);
  }

  static double getCoveragePercentage() {
    final allKeys = getAllKeys();
    final totalPossible = allKeys.length * _translations.length;
    var totalTranslated = 0;

    for (final translations in _translations.values) {
      totalTranslated += translations.length;
    }

    return totalTranslated / totalPossible;
  }
}

class TestableLocalizationsDelegate
    extends LocalizationsDelegate<TestableLocalizations> {
  const TestableLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'es', 'fr', 'de'].contains(locale.languageCode);
  }

  @override
  Future<TestableLocalizations> load(Locale locale) async {
    return TestableLocalizations(locale);
  }

  @override
  bool shouldReload(TestableLocalizationsDelegate old) => false;
}

class I18nTestingExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const I18nTestingExample({
    super.key,
    required this.onLocaleChange,
  });

  @override
  State<I18nTestingExample> createState() => _I18nTestingExampleState();
}

class _I18nTestingExampleState extends State<I18nTestingExample> {
  I18nTestResults? _testResults;

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
    Locale('de'): '🇩🇪 German',
  };

  @override
  Widget build(BuildContext context) {
    final localizations = TestableLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('app_title')),
        actions: [
          PopupMenuButton<Locale>(
            icon: const Icon(Icons.language),
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) {
              return _localeNames.entries.map((entry) {
                return PopupMenuItem<Locale>(
                  value: entry.key,
                  child: Text(entry.value),
                );
              }).toList();
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildTestControls(localizations),
            const SizedBox(height: 20),
            if (_testResults != null) ...[
              _buildTestResults(localizations),
              const SizedBox(height: 20),
            ],
            _buildSampleTexts(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildTestControls(TestableLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'I18n Testing Suite',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _runI18nTests,
                child: Text(localizations.translate('run_tests')),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTestResults(TestableLocalizations localizations) {
    if (_testResults == null) return const SizedBox();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  localizations.translate('test_results'),
                  style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const Spacer(),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                  decoration: BoxDecoration(
                    color: _testResults!.allTestsPassed ? Colors.green : Colors.red,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Text(
                    _testResults!.allTestsPassed 
                        ? localizations.translate('validation_passed')
                        : localizations.translate('validation_failed'),
                    style: const TextStyle(color: Colors.white, fontSize: 12),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildCoverageInfo(localizations),
            const SizedBox(height: 16),
            _buildMissingKeysInfo(localizations),
            const SizedBox(height: 16),
            _buildPlaceholderInfo(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildCoverageInfo(TestableLocalizations localizations) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          localizations.translate('translation_coverage'),
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        LinearProgressIndicator(
          value: _testResults!.coveragePercentage,
          backgroundColor: Colors.grey[300],
          valueColor: AlwaysStoppedAnimation<Color>(
            _testResults!.coveragePercentage > 0.8 ? Colors.green : Colors.orange,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          '${(_testResults!.coveragePercentage * 100).toStringAsFixed(1)}% of translations available',
          style: const TextStyle(fontSize: 12),
        ),
      ],
    );
  }

  Widget _buildMissingKeysInfo(TestableLocalizations localizations) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          localizations.translate('missing_keys'),
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        if (_testResults!.missingKeys.isEmpty)
          const Text('No missing keys found', style: TextStyle(color: Colors.green))
        else
          ..._testResults!.missingKeys.entries.map((entry) => Padding(
            padding: const EdgeInsets.symmetric(vertical: 2.0),
            child: Text(
              '${entry.key}: ${entry.value.length} missing keys',
              style: const TextStyle(fontSize: 12, color: Colors.red),
            ),
          )),
      ],
    );
  }

  Widget _buildPlaceholderInfo(TestableLocalizations localizations) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          localizations.translate('placeholder_detection'),
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        if (_testResults!.placeholderMismatches.isEmpty)
          const Text('No placeholder mismatches found', style: TextStyle(color: Colors.green))
        else
          ..._testResults!.placeholderMismatches.entries.map((entry) => Padding(
            padding: const EdgeInsets.symmetric(vertical: 2.0),
            child: Text(
              '${entry.key}: Mismatch in ${entry.value.join(', ')}',
              style: const TextStyle(fontSize: 12, color: Colors.orange),
            ),
          )),
      ],
    );
  }

  Widget _buildSampleTexts(TestableLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Sample Texts for Testing',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildSampleText(
              'Long Text',
              localizations.translate('sample_long_text'),
            ),
            const SizedBox(height: 12),
            _buildSampleText(
              'Parameterized Text',
              localizations.translate('sample_with_placeholder', parameters: {
                'name': 'John',
                'count': '5',
              }),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSampleText(String label, String text) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(fontWeight: FontWeight.w500),
        ),
        const SizedBox(height: 4),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey[300]!),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Text(
            text,
            style: const TextStyle(fontSize: 14),
          ),
        ),
      ],
    );
  }

  void _runI18nTests() {
    setState(() {
      _testResults = I18nTestResults(
        coveragePercentage: TestableLocalizations.getCoveragePercentage(),
        missingKeys: TestableLocalizations.getMissingKeys(),
        placeholderMismatches: TestableLocalizations.getPlaceholderMismatches(),
      );
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          _testResults!.allTestsPassed 
              ? 'All I18n tests passed!' 
              : 'Some I18n issues found',
        ),
        backgroundColor: _testResults!.allTestsPassed ? Colors.green : Colors.orange,
      ),
    );
  }
}

class I18nTestResults {
  final double coveragePercentage;
  final Map<String, List<String>> missingKeys;
  final Map<String, Set<String>> placeholderMismatches;

  I18nTestResults({
    required this.coveragePercentage,
    required this.missingKeys,
    required this.placeholderMismatches,
  });

  bool get allTestsPassed =>
      coveragePercentage > 0.8 && 
      missingKeys.isEmpty && 
      placeholderMismatches.isEmpty;
}

// Example unit tests (these would typically be in test files)
class I18nTestSuite {
  static void runUnitTests() {
    group('I18n Unit Tests', () {
      test('should load all supported locales', () {
        final supportedLocales = ['en', 'es', 'fr', 'de'];
        
        for (final locale in supportedLocales) {
          final localizations = TestableLocalizations(Locale(locale));
          expect(localizations.locale.languageCode, equals(locale));
        }
      });

      test('should have consistent placeholder usage', () {
        final mismatches = TestableLocalizations.getPlaceholderMismatches();
        expect(mismatches, isEmpty, reason: 'Placeholder mismatches found: $mismatches');
      });

      test('should have good translation coverage', () {
        final coverage = TestableLocalizations.getCoveragePercentage();
        expect(coverage, greaterThan(0.8), reason: 'Translation coverage is too low: ${(coverage * 100).toStringAsFixed(1)}%');
      });

      test('should handle missing translations gracefully', () {
        final localizations = TestableLocalizations(const Locale('de'));
        final result = localizations.translate('non_existent_key');
        expect(result, equals('non_existent_key'));
      });

      test('should replace parameters correctly', () {
        final localizations = TestableLocalizations(const Locale('en'));
        final result = localizations.translate('sample_with_placeholder', parameters: {
          'name': 'Alice',
          'count': '3',
        });
        expect(result, contains('Alice'));
        expect(result, contains('3'));
      });
    });
  }
}
```

Testing internationalization requires systematic validation of  
translation completeness, placeholder consistency, and UI adaptation  
across locales. Automated tests catch missing translations, parameter  
mismatches, and text overflow issues before they reach users. This  
comprehensive testing approach ensures reliable multilingual experiences.

## Cultural Color Preferences

Adapting color schemes and visual elements to respect cultural  
preferences and color symbolism across different regions.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    final culturalTheme = CulturalTheme.getTheme(_currentLocale);
    
    return MaterialApp(
      title: 'Cultural Color Preferences',
      locale: _currentLocale,
      theme: culturalTheme,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('zh', 'CN'),
        Locale('ja', 'JP'),
        Locale('ar', 'SA'),
        Locale('hi', 'IN'),
        Locale('de', 'DE'),
      ],
      home: CulturalColorExample(onLocaleChange: _changeLocale),
    );
  }
}

class CulturalTheme {
  static ThemeData getTheme(Locale locale) {
    switch ('${locale.languageCode}_${locale.countryCode}') {
      case 'zh_CN':
        return _chineseTheme();
      case 'ja_JP':
        return _japaneseTheme();
      case 'ar_SA':
        return _arabicTheme();
      case 'hi_IN':
        return _indianTheme();
      case 'de_DE':
        return _germanTheme();
      default:
        return _westernTheme();
    }
  }

  static ThemeData _chineseTheme() {
    return ThemeData(
      primarySwatch: Colors.red, // Red is lucky in Chinese culture
      scaffoldBackgroundColor: const Color(0xFFF5F5DC), // Beige
      colorScheme: const ColorScheme.light(
        primary: Color(0xFFDC143C), // Crimson red
        secondary: Color(0xFFFFD700), // Gold
        surface: Color(0xFFFFFFF0), // Ivory
        error: Color(0xFF8B0000), // Dark red
      ),
      cardColor: const Color(0xFFFFF8DC), // Cornsilk
    );
  }

  static ThemeData _japaneseTheme() {
    return ThemeData(
      primarySwatch: Colors.indigo,
      scaffoldBackgroundColor: const Color(0xFFF0F8FF), // Alice blue
      colorScheme: const ColorScheme.light(
        primary: Color(0xFF4B0082), // Indigo
        secondary: Color(0xFFDC143C), // Crimson
        surface: Color(0xFFFFF8F0), // Seashell
        error: Color(0xFF8B0000),
      ),
      cardColor: Colors.white,
    );
  }

  static ThemeData _arabicTheme() {
    return ThemeData(
      primarySwatch: Colors.green, // Green is significant in Islam
      scaffoldBackgroundColor: const Color(0xFFFDF5E6), // Old lace
      colorScheme: const ColorScheme.light(
        primary: Color(0xFF006400), // Dark green
        secondary: Color(0xFFFFD700), // Gold
        surface: Color(0xFFFFFFF0),
        error: Color(0xFF8B0000),
      ),
      cardColor: const Color(0xFFF5F5DC),
    );
  }

  static ThemeData _indianTheme() {
    return ThemeData(
      primarySwatch: Colors.orange,
      scaffoldBackgroundColor: const Color(0xFFFFF8DC), // Cornsilk
      colorScheme: const ColorScheme.light(
        primary: Color(0xFFFF4500), // Orange red (saffron)
        secondary: Color(0xFF32CD32), // Lime green
        surface: Color(0xFFFFFFF0),
        error: Color(0xFF8B0000),
      ),
      cardColor: Colors.white,
    );
  }

  static ThemeData _germanTheme() {
    return ThemeData(
      primarySwatch: Colors.grey,
      scaffoldBackgroundColor: Colors.grey[50],
      colorScheme: ColorScheme.light(
        primary: Colors.grey[800]!,
        secondary: Colors.red[700]!,
        surface: Colors.white,
        error: Colors.red[900]!,
      ),
      cardColor: Colors.white,
    );
  }

  static ThemeData _westernTheme() {
    return ThemeData(
      primarySwatch: Colors.blue,
      scaffoldBackgroundColor: Colors.white,
      colorScheme: const ColorScheme.light(
        primary: Colors.blue,
        secondary: Colors.green,
        surface: Colors.white,
        error: Colors.red,
      ),
    );
  }
}

class CulturalColorExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const CulturalColorExample({super.key, required this.onLocaleChange});

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 US English',
    Locale('zh', 'CN'): '🇨🇳 Chinese',
    Locale('ja', 'JP'): '🇯🇵 Japanese',
    Locale('ar', 'SA'): '🇸🇦 Arabic',
    Locale('hi', 'IN'): '🇮🇳 Hindi',
    Locale('de', 'DE'): '🇩🇪 German',
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Cultural Color Preferences'),
        actions: [
          PopupMenuButton<Locale>(
            onSelected: onLocaleChange,
            itemBuilder: (context) => _localeNames.entries.map((entry) {
              return PopupMenuItem<Locale>(
                value: entry.key,
                child: Text(entry.value),
              );
            }).toList(),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildColorExplanation(locale, theme),
            const SizedBox(height: 20),
            _buildColorPalette(theme),
            const SizedBox(height: 20),
            _buildCulturalElements(locale, theme),
          ],
        ),
      ),
    );
  }

  Widget _buildColorExplanation(Locale locale, ThemeData theme) {
    final explanations = {
      'zh_CN': 'Red symbolizes luck and prosperity in Chinese culture. Gold represents wealth.',
      'ja_JP': 'Indigo and crimson reflect traditional Japanese color preferences.',
      'ar_SA': 'Green is associated with Islam and paradise. Gold signifies luxury.',
      'hi_IN': 'Saffron orange is sacred in Hinduism, representing purity and spirituality.',
      'de_DE': 'German design favors neutral colors and high contrast.',
      'en_US': 'Western blue conveys trust and stability.',
    };

    final key = '${locale.languageCode}_${locale.countryCode}';
    final explanation = explanations[key] ?? explanations['en_US']!;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Cultural Color Significance',
              style: theme.textTheme.titleLarge,
            ),
            const SizedBox(height: 12),
            Text(explanation),
          ],
        ),
      ),
    );
  }

  Widget _buildColorPalette(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Current Color Palette', style: theme.textTheme.titleLarge),
            const SizedBox(height: 16),
            Row(
              children: [
                _buildColorSwatch('Primary', theme.colorScheme.primary),
                _buildColorSwatch('Secondary', theme.colorScheme.secondary),
                _buildColorSwatch('Surface', theme.colorScheme.surface),
                _buildColorSwatch('Error', theme.colorScheme.error),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildColorSwatch(String label, Color color) {
    return Expanded(
      child: Column(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              color: color,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.grey[300]!),
            ),
          ),
          const SizedBox(height: 8),
          Text(label, style: const TextStyle(fontSize: 12)),
        ],
      ),
    );
  }

  Widget _buildCulturalElements(Locale locale, ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Cultural UI Elements', style: theme.textTheme.titleLarge),
            const SizedBox(height: 16),
            _buildStatusIndicators(theme),
            const SizedBox(height: 16),
            _buildActionButtons(theme),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusIndicators(ThemeData theme) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildStatusChip('Success', theme.colorScheme.secondary, Icons.check),
        _buildStatusChip('Warning', Colors.orange, Icons.warning),
        _buildStatusChip('Error', theme.colorScheme.error, Icons.error),
        _buildStatusChip('Info', theme.colorScheme.primary, Icons.info),
      ],
    );
  }

  Widget _buildStatusChip(String label, Color color, IconData icon) {
    return Chip(
      avatar: Icon(icon, size: 16, color: Colors.white),
      label: Text(label, style: const TextStyle(color: Colors.white, fontSize: 12)),
      backgroundColor: color,
    );
  }

  Widget _buildActionButtons(ThemeData theme) {
    return Row(
      children: [
        Expanded(
          child: ElevatedButton(
            onPressed: () {},
            child: const Text('Primary Action'),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: OutlinedButton(
            onPressed: () {},
            child: const Text('Secondary Action'),
          ),
        ),
      ],
    );
  }
}
```

Cultural color preferences ensure your app feels familiar and appropriate  
to users from different backgrounds. Colors carry different meanings  
across cultures - red is lucky in China but can signify danger in  
Western contexts. This example adapts entire color schemes based on  
locale, respecting cultural color symbolism and design traditions.

## Pseudo-Localization Testing

Implementing pseudo-localization for testing UI layout and identifying  
hard-coded strings during development.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Pseudo-Localization Testing',
      locale: _currentLocale,
      localizationsDelegates: const [
        PseudoLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'), // Original
        Locale('pseudo'), // Pseudo-localized
        Locale('es'), // Real Spanish for comparison
      ],
      home: PseudoLocalizationExample(onLocaleChange: _changeLocale),
    );
  }
}

class PseudoLocalizations {
  final Locale locale;

  PseudoLocalizations(this.locale);

  static PseudoLocalizations? of(BuildContext context) {
    return Localizations.of<PseudoLocalizations>(
        context, PseudoLocalizations);
  }

  static const Map<String, String> _baseTranslations = {
    'app_title': 'Pseudo-Localization Testing',
    'welcome_message': 'Welcome to our application!',
    'short_text': 'OK',
    'medium_text': 'Save Changes',
    'long_text': 'This is a longer text that will help test layout flexibility',
    'very_long_text': 'This is an extremely long text string designed to test how the UI handles very lengthy translations that might wrap to multiple lines',
    'button_submit': 'Submit',
    'button_cancel': 'Cancel',
    'label_name': 'Name',
    'label_email': 'Email Address',
    'placeholder_search': 'Search...',
    'error_required': 'This field is required',
    'success_message': 'Operation completed successfully!',
  };

  static const Map<String, String> _spanishTranslations = {
    'app_title': 'Pruebas de Pseudo-Localización',
    'welcome_message': '¡Bienvenido a nuestra aplicación!',
    'short_text': 'Aceptar',
    'medium_text': 'Guardar Cambios',
    'long_text': 'Este es un texto más largo que ayudará a probar la flexibilidad del diseño',
    'very_long_text': 'Esta es una cadena de texto extremadamente larga diseñada para probar cómo maneja la interfaz de usuario las traducciones muy largas que podrían dividirse en múltiples líneas',
    'button_submit': 'Enviar',
    'button_cancel': 'Cancelar',
    'label_name': 'Nombre',
    'label_email': 'Dirección de Correo Electrónico',
    'placeholder_search': 'Buscar...',
    'error_required': 'Este campo es obligatorio',
    'success_message': '¡Operación completada exitosamente!',
  };

  String translate(String key) {
    switch (locale.languageCode) {
      case 'pseudo':
        return _pseudoLocalize(_baseTranslations[key] ?? key);
      case 'es':
        return _spanishTranslations[key] ?? _baseTranslations[key] ?? key;
      default:
        return _baseTranslations[key] ?? key;
    }
  }

  String _pseudoLocalize(String originalText) {
    // Add brackets to identify pseudo-localized text
    var result = '[${originalText}]';
    
    // Expand text by approximately 30% (common expansion factor)
    result = _expandText(result);
    
    // Add some special characters to test encoding
    result = _addSpecialCharacters(result);
    
    return result;
  }

  String _expandText(String text) {
    // Add extra characters to simulate text expansion
    final expandedLength = (text.length * 1.3).round();
    final expansion = expandedLength - text.length;
    
    if (expansion <= 0) return text;
    
    // Insert padding characters throughout the text
    final padding = 'öäüßñç' * ((expansion / 6) + 1).round();
    final paddingToUse = padding.substring(0, expansion);
    
    // Insert padding in the middle of the text
    final midPoint = text.length ~/ 2;
    return text.substring(0, midPoint) + paddingToUse + text.substring(midPoint);
  }

  String _addSpecialCharacters(String text) {
    // Replace some ASCII characters with accented versions
    return text
        .replaceAll('a', 'á')
        .replaceAll('e', 'é') 
        .replaceAll('i', 'í')
        .replaceAll('o', 'ó')
        .replaceAll('u', 'ú')
        .replaceAll('A', 'À')
        .replaceAll('E', 'È')
        .replaceAll('I', 'Ì')
        .replaceAll('O', 'Ò')
        .replaceAll('U', 'Ù');
  }
}

class PseudoLocalizationsDelegate
    extends LocalizationsDelegate<PseudoLocalizations> {
  const PseudoLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'pseudo', 'es'].contains(locale.languageCode);
  }

  @override
  Future<PseudoLocalizations> load(Locale locale) async {
    return PseudoLocalizations(locale);
  }

  @override
  bool shouldReload(PseudoLocalizationsDelegate old) => false;
}

class PseudoLocalizationExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const PseudoLocalizationExample({super.key, required this.onLocaleChange});

  @override
  State<PseudoLocalizationExample> createState() =>
      _PseudoLocalizationExampleState();
}

class _PseudoLocalizationExampleState extends State<PseudoLocalizationExample> {
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English (Original)',
    Locale('pseudo'): '🔧 Pseudo-Localized',
    Locale('es'): '🇪🇸 Spanish (Real)',
  };

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final localizations = PseudoLocalizations.of(context)!;
    final isPseudo = localizations.locale.languageCode == 'pseudo';

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('app_title')),
        backgroundColor: isPseudo ? Colors.amber[700] : null,
        actions: [
          PopupMenuButton<Locale>(
            onSelected: widget.onLocaleChange,
            itemBuilder: (context) => _localeNames.entries.map((entry) {
              return PopupMenuItem<Locale>(
                value: entry.key,
                child: Text(entry.value),
              );
            }).toList(),
          ),
        ],
      ),
      body: Container(
        color: isPseudo ? Colors.amber[50] : null,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (isPseudo) _buildPseudoWarning(),
              _buildWelcomeSection(localizations),
              const SizedBox(height: 20),
              _buildTextLengthExamples(localizations),
              const SizedBox(height: 20),
              _buildFormExample(localizations),
              const SizedBox(height: 20),
              _buildButtonExamples(localizations),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPseudoWarning() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.amber[200],
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.amber[600]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.warning, color: Colors.amber[800]),
              const SizedBox(width: 8),
              Text(
                'Pseudo-Localization Mode',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.amber[800],
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          const Text(
            'This mode helps identify:\n'
            '• Hard-coded strings (not in brackets)\n'
            '• UI layout issues with longer text\n'
            '• Character encoding problems\n'
            '• Text truncation issues',
            style: TextStyle(fontSize: 12),
          ),
        ],
      ),
    );
  }

  Widget _buildWelcomeSection(PseudoLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('welcome_message'),
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            const Text('This is hard-coded text - should be localized!'),
          ],
        ),
      ),
    );
  }

  Widget _buildTextLengthExamples(PseudoLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Text Length Testing',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildTextExample('Short', localizations.translate('short_text')),
            _buildTextExample('Medium', localizations.translate('medium_text')),
            _buildTextExample('Long', localizations.translate('long_text')),
            _buildTextExample('Very Long', localizations.translate('very_long_text')),
          ],
        ),
      ),
    );
  }

  Widget _buildTextExample(String label, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label:',
            style: const TextStyle(fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 4),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey[300]!),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(text),
          ),
        ],
      ),
    );
  }

  Widget _buildFormExample(PseudoLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Form Testing',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _nameController,
              decoration: InputDecoration(
                labelText: localizations.translate('label_name'),
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _emailController,
              decoration: InputDecoration(
                labelText: localizations.translate('label_email'),
                hintText: localizations.translate('placeholder_search'),
                border: const OutlineInputBorder(),
                errorText: localizations.translate('error_required'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildButtonExamples(PseudoLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Button Testing',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () {},
                    child: Text(localizations.translate('button_submit')),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {},
                    child: Text(localizations.translate('button_cancel')),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(localizations.translate('success_message')),
                    ),
                  );
                },
                child: Text(localizations.translate('success_message')),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

Pseudo-localization helps identify internationalization issues during  
development by creating artificial translations with expanded text,  
special characters, and clear visual markers. This technique reveals  
hard-coded strings, UI layout problems, and text truncation issues  
before real translations are available, ensuring robust international  
support from the start.

## Regional Business Logic

Implementing region-specific business rules, regulations, and  
compliance requirements for global applications.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en', 'US');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Regional Business Logic',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('en', 'GB'),
        Locale('de', 'DE'),
        Locale('fr', 'FR'),
        Locale('ja', 'JP'),
        Locale('zh', 'CN'),
      ],
      home: RegionalBusinessExample(onLocaleChange: _changeLocale),
    );
  }
}

class RegionalBusinessRules {
  static const Map<String, Map<String, dynamic>> _rules = {
    'US': {
      'tax_rate': 0.08,
      'currency': 'USD',
      'age_verification': 21,
      'privacy_law': 'CCPA',
      'features': ['credit_cards', 'paypal', 'bank_transfer'],
      'shipping_options': ['standard', 'express', 'overnight'],
      'max_purchase': 10000.0,
    },
    'GB': {
      'tax_rate': 0.20, // VAT
      'currency': 'GBP',
      'age_verification': 18,
      'privacy_law': 'UK GDPR',
      'features': ['credit_cards', 'paypal', 'bank_transfer', 'klarna'],
      'shipping_options': ['standard', 'express'],
      'max_purchase': 8000.0,
    },
    'DE': {
      'tax_rate': 0.19, // MwSt
      'currency': 'EUR',
      'age_verification': 18,
      'privacy_law': 'GDPR',
      'features': ['credit_cards', 'paypal', 'sepa', 'sofort'],
      'shipping_options': ['standard', 'express', 'dhl'],
      'max_purchase': 9999.99,
      'cookie_consent': true,
    },
    'FR': {
      'tax_rate': 0.20, // TVA
      'currency': 'EUR',
      'age_verification': 18,
      'privacy_law': 'GDPR',
      'features': ['credit_cards', 'paypal', 'sepa'],
      'shipping_options': ['standard', 'express', 'colissimo'],
      'max_purchase': 9999.99,
      'cookie_consent': true,
    },
    'JP': {
      'tax_rate': 0.10, // Consumption tax
      'currency': 'JPY',
      'age_verification': 20,
      'privacy_law': 'APPI',
      'features': ['credit_cards', 'konbini', 'bank_transfer'],
      'shipping_options': ['standard', 'express', 'yamato'],
      'max_purchase': 1000000.0,
    },
    'CN': {
      'tax_rate': 0.13, // VAT
      'currency': 'CNY',
      'age_verification': 18,
      'privacy_law': 'PIPL',
      'features': ['alipay', 'wechat_pay', 'unionpay'],
      'shipping_options': ['standard', 'express', 'sf_express'],
      'max_purchase': 50000.0,
      'content_restrictions': true,
    },
  };

  static RegionalConfig getConfig(Locale locale) {
    final countryCode = locale.countryCode ?? 'US';
    final rules = _rules[countryCode] ?? _rules['US']!;
    
    return RegionalConfig.fromMap(countryCode, rules);
  }
}

class RegionalConfig {
  final String country;
  final double taxRate;
  final String currency;
  final int ageVerification;
  final String privacyLaw;
  final List<String> features;
  final List<String> shippingOptions;
  final double maxPurchase;
  final bool cookieConsent;
  final bool contentRestrictions;

  RegionalConfig({
    required this.country,
    required this.taxRate,
    required this.currency,
    required this.ageVerification,
    required this.privacyLaw,
    required this.features,
    required this.shippingOptions,
    required this.maxPurchase,
    this.cookieConsent = false,
    this.contentRestrictions = false,
  });

  factory RegionalConfig.fromMap(String country, Map<String, dynamic> map) {
    return RegionalConfig(
      country: country,
      taxRate: map['tax_rate']?.toDouble() ?? 0.0,
      currency: map['currency'] ?? 'USD',
      ageVerification: map['age_verification'] ?? 18,
      privacyLaw: map['privacy_law'] ?? 'Generic',
      features: List<String>.from(map['features'] ?? []),
      shippingOptions: List<String>.from(map['shipping_options'] ?? []),
      maxPurchase: map['max_purchase']?.toDouble() ?? 1000.0,
      cookieConsent: map['cookie_consent'] ?? false,
      contentRestrictions: map['content_restrictions'] ?? false,
    );
  }

  String formatCurrency(double amount) {
    switch (currency) {
      case 'USD':
        return '\$${amount.toStringAsFixed(2)}';
      case 'GBP':
        return '£${amount.toStringAsFixed(2)}';
      case 'EUR':
        return '€${amount.toStringAsFixed(2)}';
      case 'JPY':
        return '¥${amount.toStringAsFixed(0)}';
      case 'CNY':
        return '¥${amount.toStringAsFixed(2)}';
      default:
        return '${amount.toStringAsFixed(2)} $currency';
    }
  }

  double calculateTax(double amount) {
    return amount * taxRate;
  }

  double calculateTotal(double subtotal) {
    return subtotal + calculateTax(subtotal);
  }

  bool isFeatureAvailable(String feature) {
    return features.contains(feature);
  }
}

class RegionalBusinessExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const RegionalBusinessExample({super.key, required this.onLocaleChange});

  @override
  State<RegionalBusinessExample> createState() => _RegionalBusinessExampleState();
}

class _RegionalBusinessExampleState extends State<RegionalBusinessExample> {
  double _itemPrice = 100.0;
  String _selectedPayment = '';
  String _selectedShipping = '';

  static const Map<Locale, String> _localeNames = {
    Locale('en', 'US'): '🇺🇸 United States',
    Locale('en', 'GB'): '🇬🇧 United Kingdom',
    Locale('de', 'DE'): '🇩🇪 Germany',
    Locale('fr', 'FR'): '🇫🇷 France',
    Locale('ja', 'JP'): '🇯🇵 Japan',
    Locale('zh', 'CN'): '🇨🇳 China',
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final config = RegionalBusinessRules.getConfig(locale);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Regional Business Logic'),
        actions: [
          PopupMenuButton<Locale>(
            onSelected: (newLocale) {
              widget.onLocaleChange(newLocale);
              // Reset selections when changing regions
              setState(() {
                _selectedPayment = '';
                _selectedShipping = '';
              });
            },
            itemBuilder: (context) => _localeNames.entries.map((entry) {
              return PopupMenuItem<Locale>(
                value: entry.key,
                child: Text(entry.value),
              );
            }).toList(),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildRegionalInfo(config),
            const SizedBox(height: 20),
            _buildPriceCalculator(config),
            const SizedBox(height: 20),
            _buildPaymentMethods(config),
            const SizedBox(height: 20),
            _buildShippingOptions(config),
            const SizedBox(height: 20),
            _buildComplianceInfo(config),
          ],
        ),
      ),
    );
  }

  Widget _buildRegionalInfo(RegionalConfig config) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Regional Configuration: ${config.country}',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildInfoRow('Currency', config.currency),
            _buildInfoRow('Tax Rate', '${(config.taxRate * 100).toStringAsFixed(1)}%'),
            _buildInfoRow('Age Verification', '${config.ageVerification} years'),
            _buildInfoRow('Privacy Law', config.privacyLaw),
            _buildInfoRow('Max Purchase', config.formatCurrency(config.maxPurchase)),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text('$label:', style: const TextStyle(fontWeight: FontWeight.w500)),
          ),
          Text(value),
        ],
      ),
    );
  }

  Widget _buildPriceCalculator(RegionalConfig config) {
    final tax = config.calculateTax(_itemPrice);
    final total = config.calculateTotal(_itemPrice);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Price Calculator',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                const Text('Item Price: '),
                Expanded(
                  child: Slider(
                    value: _itemPrice,
                    min: 10,
                    max: config.maxPurchase,
                    divisions: 100,
                    onChanged: (value) => setState(() => _itemPrice = value),
                  ),
                ),
                Text(config.formatCurrency(_itemPrice)),
              ],
            ),
            const SizedBox(height: 16),
            _buildPriceRow('Subtotal', config.formatCurrency(_itemPrice)),
            _buildPriceRow('Tax', config.formatCurrency(tax)),
            const Divider(),
            _buildPriceRow('Total', config.formatCurrency(total), isTotal: true),
          ],
        ),
      ),
    );
  }

  Widget _buildPriceRow(String label, String amount, {bool isTotal = false}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: TextStyle(
              fontSize: isTotal ? 16 : 14,
              fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
            ),
          ),
          Text(
            amount,
            style: TextStyle(
              fontSize: isTotal ? 16 : 14,
              fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPaymentMethods(RegionalConfig config) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Available Payment Methods',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            ...config.features.map((feature) => RadioListTile<String>(
              title: Text(_getPaymentMethodName(feature)),
              value: feature,
              groupValue: _selectedPayment,
              onChanged: (value) => setState(() => _selectedPayment = value!),
            )),
          ],
        ),
      ),
    );
  }

  Widget _buildShippingOptions(RegionalConfig config) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Shipping Options',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            ...config.shippingOptions.map((option) => RadioListTile<String>(
              title: Text(_getShippingName(option)),
              value: option,
              groupValue: _selectedShipping,
              onChanged: (value) => setState(() => _selectedShipping = value!),
            )),
          ],
        ),
      ),
    );
  }

  Widget _buildComplianceInfo(RegionalConfig config) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Compliance Requirements',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            if (config.cookieConsent) _buildComplianceItem(
              'Cookie Consent Required',
              'User must consent to cookie usage (GDPR)',
            ),
            if (config.contentRestrictions) _buildComplianceItem(
              'Content Restrictions',
              'Content must comply with local regulations',
            ),
            _buildComplianceItem(
              'Age Verification',
              'Users must be ${config.ageVerification}+ for restricted content',
            ),
            _buildComplianceItem(
              'Privacy Compliance',
              'Must comply with ${config.privacyLaw}',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildComplianceItem(String title, String description) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(Icons.check_circle, color: Colors.green, size: 20),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
                Text(description, style: const TextStyle(fontSize: 12)),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _getPaymentMethodName(String feature) {
    const names = {
      'credit_cards': 'Credit/Debit Cards',
      'paypal': 'PayPal',
      'bank_transfer': 'Bank Transfer',
      'klarna': 'Klarna',
      'sepa': 'SEPA Direct Debit',
      'sofort': 'Sofort Banking',
      'konbini': 'Konbini Payment',
      'alipay': 'Alipay',
      'wechat_pay': 'WeChat Pay',
      'unionpay': 'UnionPay',
    };
    return names[feature] ?? feature;
  }

  String _getShippingName(String option) {
    const names = {
      'standard': 'Standard Shipping',
      'express': 'Express Shipping',
      'overnight': 'Overnight Delivery',
      'dhl': 'DHL Express',
      'colissimo': 'Colissimo',
      'yamato': 'Yamato Transport',
      'sf_express': 'SF Express',
    };
    return names[option] ?? option;
  }
}
```

Regional business logic ensures your app complies with local laws,  
supports appropriate payment methods, and follows regional business  
practices. Different countries have varying tax rates, age restrictions,  
privacy laws, and preferred payment systems. This systematic approach  
adapts functionality based on user location while maintaining compliance.

## Advanced Text Processing

Handling complex text processing requirements including text shaping,  
bidirectional text, and script-specific typography.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Advanced Text Processing',
      locale: _currentLocale,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('ar'),
        Locale('he'),
        Locale('hi'),
        Locale('th'),
        Locale('ja'),
        Locale('zh'),
      ],
      home: AdvancedTextExample(onLocaleChange: _changeLocale),
    );
  }
}

class AdvancedTextExample extends StatelessWidget {
  final Function(Locale) onLocaleChange;

  const AdvancedTextExample({super.key, required this.onLocaleChange});

  static const Map<Locale, Map<String, String>> _sampleTexts = {
    Locale('en'): {
      'text': 'The quick brown fox jumps over the lazy dog.',
      'mixed': 'English text with عربي and עברית mixed in.',
      'numbers': 'Phone: +1-555-123-4567, Price: \$1,234.56',
    },
    Locale('ar'): {
      'text': 'النص العربي يُكتب من اليمين إلى اليسار بطبيعة الحال.',
      'mixed': 'النص العربي مع English و עברית مختلط.',
      'numbers': 'الهاتف: ١٢٣-٤٥٦-٧٨٩٠، السعر: ١٢٣٤.٥٦ ريال',
    },
    Locale('he'): {
      'text': 'הטקסט בעברית נכתב מימין לשמאל כמו בערבית.',
      'mixed': 'טקסט עברית עם English וגם عربي מעורב.',
      'numbers': 'טלפון: 050-123-4567, מחיר: ₪1,234.56',
    },
    Locale('hi'): {
      'text': 'हिंदी देवनागरी लिपि में लिखी जाती है और यह बाएं से दाएं लिखी जाती है।',
      'mixed': 'हिंदी text with English mixed में।',
      'numbers': 'फोन: +91-98765-43210, कीमत: ₹1,234.56',
    },
    Locale('th'): {
      'text': 'ภาษาไทยเป็นภาษาที่มีวรรณยุกต์และไม่มีช่องว่างระหว่างคำ',
      'mixed': 'ข้อความภาษาไทยผสม English text together',
      'numbers': 'โทร: 02-123-4567, ราคา: ฿1,234.56',
    },
    Locale('ja'): {
      'text': '日本語はひらがな、カタカナ、漢字の三つの文字体系を使用します。',
      'mixed': '日本語とEnglishとが混在したtext。',
      'numbers': '電話: 03-1234-5678, 価格: ¥1,234',
    },
    Locale('zh'): {
      'text': '中文可以是简体中文或繁体中文，都是从左到右书写。',
      'mixed': '中文与English混合的text样例。',
      'numbers': '电话: 010-1234-5678, 价格: ¥1,234.56',
    },
  };

  @override
  Widget build(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final isRTL = _isRTLLanguage(locale.languageCode);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Advanced Text Processing'),
        actions: [
          PopupMenuButton<Locale>(
            onSelected: onLocaleChange,
            itemBuilder: (context) => _sampleTexts.keys.map((locale) {
              return PopupMenuItem<Locale>(
                value: locale,
                child: Text(_getLocaleName(locale)),
              );
            }).toList(),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildTextInfo(locale, isRTL),
            const SizedBox(height: 20),
            _buildTextDirectionDemo(locale),
            const SizedBox(height: 20),
            _buildBidirectionalTextDemo(locale),
            const SizedBox(height: 20),
            _buildNumberFormattingDemo(locale),
            const SizedBox(height: 20),
            _buildTypographyDemo(locale),
          ],
        ),
      ),
    );
  }

  Widget _buildTextInfo(Locale locale, bool isRTL) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Text Processing Information',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildInfoRow('Language', locale.languageCode),
            _buildInfoRow('Script Direction', isRTL ? 'RTL' : 'LTR'),
            _buildInfoRow('Script Type', _getScriptType(locale.languageCode)),
            _buildInfoRow('Complex Shaping', _hasComplexShaping(locale.languageCode) ? 'Yes' : 'No'),
            _buildInfoRow('Combining Characters', _hasCombiningChars(locale.languageCode) ? 'Yes' : 'No'),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          SizedBox(
            width: 140,
            child: Text('$label:', style: const TextStyle(fontWeight: FontWeight.w500)),
          ),
          Text(value),
        ],
      ),
    );
  }

  Widget _buildTextDirectionDemo(Locale locale) {
    final sampleText = _sampleTexts[locale]?['text'] ?? 'Sample text not available';
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Text Direction Demo',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildTextDemo('Automatic Direction', sampleText, null),
            _buildTextDemo('Force LTR', sampleText, TextDirection.ltr),
            _buildTextDemo('Force RTL', sampleText, TextDirection.rtl),
          ],
        ),
      ),
    );
  }

  Widget _buildTextDemo(String title, String text, TextDirection? direction) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
          const SizedBox(height: 4),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey[300]!),
              borderRadius: BorderRadius.circular(4),
            ),
            child: direction != null
                ? Directionality(
                    textDirection: direction,
                    child: Text(text),
                  )
                : Text(text),
          ),
        ],
      ),
    );
  }

  Widget _buildBidirectionalTextDemo(Locale locale) {
    final mixedText = _sampleTexts[locale]?['mixed'] ?? 'Mixed text not available';
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Bidirectional Text Demo',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey[300]!),
                borderRadius: BorderRadius.circular(4),
                color: Colors.yellow[50],
              ),
              child: Text(
                mixedText,
                style: const TextStyle(fontSize: 16),
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Note: Text automatically adjusts direction based on character properties',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNumberFormattingDemo(Locale locale) {
    final numbersText = _sampleTexts[locale]?['numbers'] ?? 'Numbers not available';
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Number and Currency Demo',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey[300]!),
                borderRadius: BorderRadius.circular(4),
                color: Colors.blue[50],
              ),
              child: Text(
                numbersText,
                style: const TextStyle(fontSize: 16),
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Note: Numbers may display differently based on locale (Arabic numerals vs. local numerals)',
              style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTypographyDemo(Locale locale) {
    final sampleText = _sampleTexts[locale]?['text'] ?? 'Sample text';
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Typography Demo',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildTypographyExample('Small', sampleText, 12),
            _buildTypographyExample('Medium', sampleText, 16),
            _buildTypographyExample('Large', sampleText, 20),
            _buildTypographyExample('Extra Large', sampleText, 24),
          ],
        ),
      ),
    );
  }

  Widget _buildTypographyExample(String label, String text, double fontSize) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label (${fontSize}px):',
            style: const TextStyle(fontWeight: FontWeight.w500, fontSize: 12),
          ),
          Text(
            text,
            style: TextStyle(fontSize: fontSize),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
          const SizedBox(height: 8),
        ],
      ),
    );
  }

  bool _isRTLLanguage(String languageCode) {
    return ['ar', 'he', 'fa', 'ur'].contains(languageCode);
  }

  String _getScriptType(String languageCode) {
    const scripts = {
      'en': 'Latin',
      'ar': 'Arabic',
      'he': 'Hebrew',
      'hi': 'Devanagari',
      'th': 'Thai',
      'ja': 'Hiragana/Katakana/Kanji',
      'zh': 'Chinese Characters',
    };
    return scripts[languageCode] ?? 'Unknown';
  }

  bool _hasComplexShaping(String languageCode) {
    return ['ar', 'he', 'hi', 'th'].contains(languageCode);
  }

  bool _hasCombiningChars(String languageCode) {
    return ['ar', 'he', 'hi', 'th'].contains(languageCode);
  }

  String _getLocaleName(Locale locale) {
    const names = {
      'en': '🇺🇸 English',
      'ar': '🇸🇦 Arabic',
      'he': '🇮🇱 Hebrew',
      'hi': '🇮🇳 Hindi',
      'th': '🇹🇭 Thai',
      'ja': '🇯🇵 Japanese',
      'zh': '🇨🇳 Chinese',
    };
    return names[locale.languageCode] ?? locale.languageCode;
  }
}
```

Advanced text processing handles complex typography requirements across  
different writing systems. This includes bidirectional text rendering,  
script-specific shaping, combining characters, and proper text direction  
handling. These features are essential for supporting global languages  
with their unique typographic traditions and requirements.

## Migration and Version Management

Managing internationalization updates, migration strategies, and  
backward compatibility when evolving multilingual applications.  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  Locale _currentLocale = const Locale('en');

  void _changeLocale(Locale newLocale) {
    setState(() {
      _currentLocale = newLocale;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'I18n Migration & Versioning',
      locale: _currentLocale,
      localizationsDelegates: const [
        MigrationAwareLocalizationsDelegate(),
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('es'),
        Locale('fr'),
      ],
      home: MigrationExample(onLocaleChange: _changeLocale),
    );
  }
}

class TranslationVersion {
  final String version;
  final DateTime releaseDate;
  final Map<String, String> translations;
  final List<String> deprecatedKeys;
  final List<String> newKeys;

  TranslationVersion({
    required this.version,
    required this.releaseDate,
    required this.translations,
    this.deprecatedKeys = const [],
    this.newKeys = const [],
  });
}

class MigrationAwareLocalizations {
  final Locale locale;
  
  static final Map<String, List<TranslationVersion>> _versionHistory = {
    'en': [
      TranslationVersion(
        version: '1.0.0',
        releaseDate: DateTime(2023, 1, 1),
        translations: {
          'app_title': 'My Application',
          'welcome': 'Welcome!',
          'old_button': 'Click Me', // Deprecated in 2.0.0
          'settings': 'Settings',
        },
      ),
      TranslationVersion(
        version: '2.0.0',
        releaseDate: DateTime(2023, 6, 1),
        translations: {
          'app_title': 'My Awesome Application',
          'welcome': 'Welcome to our app!',
          'action_button': 'Take Action', // Replaces old_button
          'settings': 'Settings',
          'profile': 'User Profile', // New in 2.0.0
        },
        deprecatedKeys: ['old_button'],
        newKeys: ['action_button', 'profile'],
      ),
      TranslationVersion(
        version: '2.1.0',
        releaseDate: DateTime(2023, 9, 1),
        translations: {
          'app_title': 'My Awesome Application',
          'welcome': 'Welcome to our app!',
          'action_button': 'Take Action',
          'settings': 'Settings',
          'profile': 'User Profile',
          'notifications': 'Notifications', // New in 2.1.0
          'dark_mode': 'Dark Mode', // New in 2.1.0
        },
        newKeys: ['notifications', 'dark_mode'],
      ),
    ],
    'es': [
      TranslationVersion(
        version: '1.0.0',
        releaseDate: DateTime(2023, 2, 1),
        translations: {
          'app_title': 'Mi Aplicación',
          'welcome': '¡Bienvenido!',
          'old_button': 'Haz Clic',
          'settings': 'Configuración',
        },
      ),
      TranslationVersion(
        version: '2.0.0',
        releaseDate: DateTime(2023, 7, 1),
        translations: {
          'app_title': 'Mi Increíble Aplicación',
          'welcome': '¡Bienvenido a nuestra aplicación!',
          'action_button': 'Tomar Acción',
          'settings': 'Configuración',
          'profile': 'Perfil de Usuario',
        },
        deprecatedKeys: ['old_button'],
        newKeys: ['action_button', 'profile'],
      ),
      // Note: Spanish 2.1.0 is missing (incomplete translation)
    ],
    'fr': [
      TranslationVersion(
        version: '1.0.0',
        releaseDate: DateTime(2023, 3, 1),
        translations: {
          'app_title': 'Mon Application',
          'welcome': 'Bienvenue!',
          'old_button': 'Cliquez Ici',
          'settings': 'Paramètres',
        },
      ),
      // Note: French 2.0.0 and 2.1.0 are missing (incomplete translation)
    ],
  };

  MigrationAwareLocalizations(this.locale);

  static MigrationAwareLocalizations? of(BuildContext context) {
    return Localizations.of<MigrationAwareLocalizations>(
        context, MigrationAwareLocalizations);
  }

  String translate(String key, {String? fallbackVersion}) {
    final languageCode = locale.languageCode;
    final versions = _versionHistory[languageCode] ?? [];
    
    if (versions.isEmpty) {
      return key; // No translations available
    }

    // Try latest version first
    final latestVersion = versions.last;
    if (latestVersion.translations.containsKey(key)) {
      return latestVersion.translations[key]!;
    }

    // Try specific fallback version if provided
    if (fallbackVersion != null) {
      final fallbackVer = versions.firstWhere(
        (v) => v.version == fallbackVersion,
        orElse: () => versions.first,
      );
      if (fallbackVer.translations.containsKey(key)) {
        return '[v${fallbackVer.version}] ${fallbackVer.translations[key]!}';
      }
    }

    // Try previous versions (backward compatibility)
    for (int i = versions.length - 2; i >= 0; i--) {
      if (versions[i].translations.containsKey(key)) {
        return '[v${versions[i].version}] ${versions[i].translations[key]!}';
      }
    }

    // Try English fallback if not English
    if (languageCode != 'en') {
      final englishVersions = _versionHistory['en'] ?? [];
      for (final version in englishVersions.reversed) {
        if (version.translations.containsKey(key)) {
          return '[EN] ${version.translations[key]!}';
        }
      }
    }

    return '[$key]'; // Key not found anywhere
  }

  TranslationVersion? getCurrentVersion() {
    final versions = _versionHistory[locale.languageCode] ?? [];
    return versions.isNotEmpty ? versions.last : null;
  }

  List<TranslationVersion> getVersionHistory() {
    return _versionHistory[locale.languageCode] ?? [];
  }

  MigrationReport generateMigrationReport() {
    final versions = getVersionHistory();
    final currentVersion = getCurrentVersion();
    final englishVersions = _versionHistory['en'] ?? [];
    final latestEnglish = englishVersions.isNotEmpty ? englishVersions.last : null;

    var missingKeys = <String>[];
    var outdatedKeys = <String>[];
    var deprecatedKeys = <String>[];

    if (latestEnglish != null && currentVersion != null) {
      // Find missing keys
      missingKeys = latestEnglish.translations.keys
          .where((key) => !currentVersion.translations.containsKey(key))
          .toList();

      // Find deprecated keys still in use
      deprecatedKeys = currentVersion.translations.keys
          .where((key) => 
              englishVersions.any((v) => v.deprecatedKeys.contains(key)))
          .toList();
    }

    return MigrationReport(
      currentVersion: currentVersion?.version ?? 'N/A',
      latestVersion: latestEnglish?.version ?? 'N/A',
      missingKeys: missingKeys,
      outdatedKeys: outdatedKeys,
      deprecatedKeys: deprecatedKeys,
      translationCoverage: currentVersion != null && latestEnglish != null
          ? currentVersion.translations.length / latestEnglish.translations.length
          : 0.0,
    );
  }

  static List<String> getAllLanguages() {
    return _versionHistory.keys.toList();
  }

  static String getLatestVersion(String languageCode) {
    final versions = _versionHistory[languageCode] ?? [];
    return versions.isNotEmpty ? versions.last.version : 'N/A';
  }
}

class MigrationReport {
  final String currentVersion;
  final String latestVersion;
  final List<String> missingKeys;
  final List<String> outdatedKeys;
  final List<String> deprecatedKeys;
  final double translationCoverage;

  MigrationReport({
    required this.currentVersion,
    required this.latestVersion,
    required this.missingKeys,
    required this.outdatedKeys,
    required this.deprecatedKeys,
    required this.translationCoverage,
  });

  bool get needsUpdate => currentVersion != latestVersion;
  bool get hasIssues => missingKeys.isNotEmpty || 
                       outdatedKeys.isNotEmpty || 
                       deprecatedKeys.isNotEmpty;
}

class MigrationAwareLocalizationsDelegate
    extends LocalizationsDelegate<MigrationAwareLocalizations> {
  const MigrationAwareLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'es', 'fr'].contains(locale.languageCode);
  }

  @override
  Future<MigrationAwareLocalizations> load(Locale locale) async {
    return MigrationAwareLocalizations(locale);
  }

  @override
  bool shouldReload(MigrationAwareLocalizationsDelegate old) => false;
}

class MigrationExample extends StatefulWidget {
  final Function(Locale) onLocaleChange;

  const MigrationExample({super.key, required this.onLocaleChange});

  @override
  State<MigrationExample> createState() => _MigrationExampleState();
}

class _MigrationExampleState extends State<MigrationExample> {
  MigrationReport? _report;

  static const Map<Locale, String> _localeNames = {
    Locale('en'): '🇺🇸 English',
    Locale('es'): '🇪🇸 Spanish',
    Locale('fr'): '🇫🇷 French',
  };

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _generateReport());
  }

  @override
  Widget build(BuildContext context) {
    final localizations = MigrationAwareLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('app_title')),
        actions: [
          PopupMenuButton<Locale>(
            onSelected: (locale) {
              widget.onLocaleChange(locale);
              Future.delayed(const Duration(milliseconds: 100), _generateReport);
            },
            itemBuilder: (context) => _localeNames.entries.map((entry) {
              return PopupMenuItem<Locale>(
                value: entry.key,
                child: Text(entry.value),
              );
            }).toList(),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildCurrentVersionInfo(localizations),
            const SizedBox(height: 20),
            _buildSampleContent(localizations),
            const SizedBox(height: 20),
            if (_report != null) _buildMigrationReport(),
            const SizedBox(height: 20),
            _buildVersionHistory(localizations),
          ],
        ),
      ),
    );
  }

  Widget _buildCurrentVersionInfo(MigrationAwareLocalizations localizations) {
    final currentVersion = localizations.getCurrentVersion();
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Current Translation Version',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            if (currentVersion != null) ...[
              _buildInfoRow('Version', currentVersion.version),
              _buildInfoRow('Release Date', 
                  '${currentVersion.releaseDate.day}/${currentVersion.releaseDate.month}/${currentVersion.releaseDate.year}'),
              _buildInfoRow('Keys Count', '${currentVersion.translations.length}'),
              if (currentVersion.newKeys.isNotEmpty)
                _buildInfoRow('New Keys', currentVersion.newKeys.join(', ')),
              if (currentVersion.deprecatedKeys.isNotEmpty)
                _buildInfoRow('Deprecated', currentVersion.deprecatedKeys.join(', ')),
            ] else
              const Text('No version information available'),
          ],
        ),
      ),
    );
  }

  Widget _buildSampleContent(MigrationAwareLocalizations localizations) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Sample Content',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Text(localizations.translate('welcome')),
            const SizedBox(height: 8),
            Text(localizations.translate('profile')), // May show version info
            const SizedBox(height: 8),
            Text(localizations.translate('notifications')), // May not exist in older versions
            const SizedBox(height: 8),
            Text(localizations.translate('old_button')), // Deprecated, shows version
            const SizedBox(height: 16),
            Row(
              children: [
                ElevatedButton(
                  onPressed: () {},
                  child: Text(localizations.translate('action_button')),
                ),
                const SizedBox(width: 16),
                OutlinedButton(
                  onPressed: () {},
                  child: Text(localizations.translate('settings')),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMigrationReport() {
    if (_report == null) return const SizedBox();

    return Card(
      color: _report!.hasIssues ? Colors.red[50] : Colors.green[50],
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  _report!.hasIssues ? Icons.warning : Icons.check_circle,
                  color: _report!.hasIssues ? Colors.red : Colors.green,
                ),
                const SizedBox(width: 8),
                const Text(
                  'Migration Report',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildInfoRow('Current Version', _report!.currentVersion),
            _buildInfoRow('Latest Version', _report!.latestVersion),
            _buildInfoRow('Coverage', 
                '${(_report!.translationCoverage * 100).toStringAsFixed(1)}%'),
            if (_report!.needsUpdate) ...[
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Update Available',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    Text('${_report!.latestVersion} is available'),
                  ],
                ),
              ),
            ],
            if (_report!.missingKeys.isNotEmpty) ...[
              const SizedBox(height: 12),
              _buildIssueSection('Missing Keys', _report!.missingKeys, Colors.red),
            ],
            if (_report!.deprecatedKeys.isNotEmpty) ...[
              const SizedBox(height: 12),
              _buildIssueSection('Deprecated Keys', _report!.deprecatedKeys, Colors.orange),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildIssueSection(String title, List<String> items, Color color) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(fontWeight: FontWeight.bold, color: color),
          ),
          ...items.map((item) => Text('• $item', style: TextStyle(color: color))),
        ],
      ),
    );
  }

  Widget _buildVersionHistory(MigrationAwareLocalizations localizations) {
    final versions = localizations.getVersionHistory();
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Version History',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            if (versions.isEmpty)
              const Text('No version history available')
            else
              ...versions.reversed.map((version) => _buildVersionTile(version)),
          ],
        ),
      ),
    );
  }

  Widget _buildVersionTile(TranslationVersion version) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.blue[100],
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              'v${version.version}',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('${version.releaseDate.day}/${version.releaseDate.month}/${version.releaseDate.year}'),
                Text('${version.translations.length} keys'),
                if (version.newKeys.isNotEmpty)
                  Text('New: ${version.newKeys.join(', ')}', 
                       style: const TextStyle(color: Colors.green, fontSize: 12)),
                if (version.deprecatedKeys.isNotEmpty)
                  Text('Deprecated: ${version.deprecatedKeys.join(', ')}',
                       style: const TextStyle(color: Colors.red, fontSize: 12)),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text('$label:', style: const TextStyle(fontWeight: FontWeight.w500)),
          ),
          Expanded(child: Text(value)),
        ],
      ),
    );
  }

  void _generateReport() {
    final localizations = MigrationAwareLocalizations.of(context);
    if (localizations != null) {
      setState(() {
        _report = localizations.generateMigrationReport();
      });
    }
  }
}
```

Migration and version management ensures smooth evolution of  
internationalized applications. This system tracks translation versions,  
identifies missing or deprecated keys, manages backward compatibility,  
and provides migration reports. Proper versioning prevents breaking  
changes while enabling systematic translation updates across multiple  
languages and development cycles.
